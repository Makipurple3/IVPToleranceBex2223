---
title: "BEX 2223 MAungKyaw"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
# Set global knitr options
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction


## 0.Opening the data
### Loading data

```{r LoadData, include=FALSE}

# Load knitr for  markdown outputs
library(knitr)

##Load pander for better presentation of the outputs
library(pander)

##Load dplyr for better manipulation of the data
library(dplyr)

# Load readxl package to import the data
library("readxl")

# Read xlsx files
Boxex <- read_xls("/Users/maki/Desktop/Master Thesis/BEX 2223 Master Thesis MAung Kyaw/Makipurple3/Box Experiments.xls")

``` 

* First I downloaded the **knitr package** to create outputs as html, pdf or word files when knitting my r markdown file.I also loaded nd the **pander** package for better presentation
* The **dplyr** package was installed for better manipulation of the data as filtering or creating new variables
* Then, I installed the **readxl package** to import my dataset which is called **Box Experiments.xls**
* This dataset contains information related to my master thesis project. I used cyber tracker in order to record the behaviors of dyads of Vervet monkeys in a box experiment on tolerance from September 2022 to September 2023

## 1.Explore the data

### Description of the initial datset - "Boxex"

```{r View and Glimpse of Boxex, echo=FALSE}

# First view of my datset
View(Boxex)

#GLimpse function to see the summary and  the structure

cat("Glimpse of the the Box Experiment dataset:\n\n")
glimpse(Boxex)
```



* I am now using the **glimpse** function to display a summary of my dataset
* I have **20 columns** (here variables) and **2795 rows** (here trials)

* I will now make a brief summary of each variables and their use before creating a new dataframe (df) with my variables of interest

* The highlighted variables are the ones I will use for my new df. I will then **clean the data** before heading to the **statistical analysis**


#### Variables of Boxex

* **Date**               :
    "Date" is in ac**POSIXct** format which is appropriate for the display of time 

    * I want to use the date to know **how many sessions** have been done with each dyads in my experiment. 
    * I will create a variable called **Session** where **1 session = 1 day**
    * The data has values from the **14th of September 2022** until the **13th of September 2023**
    * I may consider separating the **12 months** of data in **4 seasons** to make a preliminary check of a potential effect of seasonality. Nevertheless we did not use any tools to measure the weather,         temperature, humidity or food availability (also related to seasonality and weather). Categorizing my data in 4 without having further data would then be quite arbitrary. If I end up doing it in my          report, it will be done without any intention to include it in scientific analysis nor my scientific report .
    

    
* **Time**                  : 
     "Time is coded" in a **POSIXct** format 
     
    * I do not plan to use this variable but we can see that "Time" has hours displayed with a date which is incorrect. 
    * (In the case I wanted to observe **when the trials occurred during the day** as time may have an influence on their behavior) **SOURCE**I would need to correct the incorrect display of the date in the     dataset.
    * This variable could also be usefull to see when  the **seasonal effect** took place as we only went in the morning during summer because of the heat while we went later and for longer times in the          field to do the box experiment in winter 
    * For now, the values in "Time" are all on the same (wrong) day which is the **31st  of December** 
    * Nevertheless I am not going to use this variable
    
    
* Data                   : chr 
    "Data" is coded as **character**
    * It describes **the type of data** being recorded in the software **cybertracker**. We installed the software on tablets to record the different behaviors of vervet monkeys in our research center
    * In our case, my data was recorded in cybertracker as **Box Experiment** as we created a form specifically for this experiment
    * For this reason we can remove this column as the information is unecessary
      
* Group             : chr 
    The data is coded in r as a **character**
    * It describes the **group of monkey** in which we did the trial
    * I will keep this column to see theamount of trials that we did in the 3 group of monkeys which are Baie-Dankie **(BD)**, Ankhase **(AK)**, and Noha **(NH)**
      
* GPSS                   : num 
    "GPSS" is coded as **numerical**
    * It gives the **south coordinates** in which we started the experiment
    * I do not plan to use coordinates nor look at locations so I will remove this acolumn
    
* GPSE                   : num 
    "GPSE" is coded in as **numerical**
    * It gives the **east coordinates** in which we started the experiment
    * I do not plan to use coordinates nor look at locations so I will remove this column
  
* **MaleID**             : chr 
    "MaleID" is coded as **character**
    * It gives the **name of the male involved in the trial**
    * I plan to use this to see how factors related to the individual may influence the            experiment (age, sex, rank)
    * It will also help me see which behaviour was displayed by each individuals (here males)
  
  
* **FemaleID**           : chr
    "FemaleID" is coded as **character**
    * It gives the **name of the female involved in the trial**
    * I plan to use this variable in the same way as "Male ID"
    * It will also help me see which behaviour was displayed by each individuals (here females)
    
  
  
* **Male placement corn**: dbl
    "Male placement corn is coded in r as **double**
    * It gives the **amount of corn given to the monkey of the dyad before the trials**
    * Within a session it happened that we gave more placement corn to attract the monkeys again to the boxes. This lead to an update of the number in the same session. The number found at the end of the         session is the total placement corn an individual has received
    * I will fuse this column with **male corn***as the data has been separated between these two variables. This is due to a mistake when creating the original box experiment form in cybertracker
    
    * This variable could be related to the level of motivation of a monkey but as it is not directly related to my hypothesis I may not use this column. I will re-consider the use of this column later on
    * In regards of this possibility I will change the format of the variable to numerical 
  
  
* **MaleCorn**           : dbl
    "MaleCorn" is coded in r as **double**
    * It gives the same information as in ***male placement corn***
    * I will import the values from "male placement corn" into this one
    * I will change the format of the variable to numerical 
    
    
* **FemaleCorn**         : dbl
    The data is coded in r as **double**
    * It gives the **amount of corn given to the monkey before the trials**
    * It works in the same way as "male placement corn"/"MaleCORN"
    * I will change the format of the varaible to numerical 
  
  
* **DyadDistance**       : chr 
    The data is coded in r as **character**
    * I gives the **distance for each trial** we have done with the dyads. 
    * The trial number 1 for each dyad was at 5 meters. 
    * The maximum was around 10 m while the minimum is 0
    * We will have to remove the "m" for meters in order to have a numerical variable insterad of character
    
  
* **DyadResponse**       : chr 
    The data is coded in r as **character**
    * It gives the code of **the behaviour produced by each dyad per trial**
    * The different behaviours were: **Distracted**, **Female aggress male**, **Male aggress female**, **Intrusion**, **Loosing interest**, **Not approaching**, **Tolerance** and **Other**
    * I will change the columns associated to each behavior (i.e. Response) of  **DyadResponse**    into dichotomic variables in order to see the frequency of each behaviour
    * This will allow me to see which behavior occured more than others, and what differences are between dydads 
    * As multiple response could occur within the same trial, multiple behaviors can be found in a single cell. I will create a  hierarchy to reduce the amount of behaviors assigned to each trial (if  there     is more than one). This will also be complemented with the information found in the column comments
      1. correct any mistakes (ex. if tolerance and aggression are together aggression>tolerance)
      2. assign as few labels per trial 
      3. get a better view and understanding of the data and the most common behaviours produced by each dyad
      4. create variables that can complement the behaviour found (ex. not approaching + looks at partner would be looks at partner + a new variable called hesistant to see when the did not come but look at         the other individual / )
      
    * Projection of the hierarchy (changes will be made)
      - Create a table with each combination existing
      
      - Decide what is more important
      - Ex:
        - Aggression > Tolerance
        - Tolerance > Not approaching -> Create a variable called hesistant in         addtion to the tolerance count to see frequency of tolerance                 behaviour that happened after > 1min
        - Tolerance > Loosing interest
        - Tolerance > Intrusion
        - Not approaching = looking box but not coming while Loosing interest           = not paying attention to the box
        - Intrusion > Loosing interest
        - Intrusion > Not approaching
        - Not approaching > Looks at partner
        - We can code every look at partner as no approaching and keep the             count of looks at partner as additional information
        - Not approaching >?> Loosing interest ? !!
        - Define distracted
        - Not approaching > Distracted
        - Aggression > Not approaching
        - Other > Look case by case and categorize depending of behavior
        - Remarks may be used for the same reason
        
  
* **OtherResponse**      : chr 
    "The data"OtherResponse" is coded as **character**
    * It describes **Any behaviour that is not included in the  ones from Dyad Response**     (meaning ≠ tolerance, aggression, intrusion, loosing interest, not approaching, distracted)
    * I will have to look at every **OtherResponse** and rename each entry in one of the response already if exstiting. I will proceed case by case.
    * If I want to do an intermediate manipulation I may rename every NA in "OtherResponse" into **Response** to see the amount of case to treat and how many occurences seem to not fit in the categories of        "DyadResponse"
    
* **Audience**      : chr 
    "Audience" is r as **character**
    * It gives the **names of the individuals in the audience**
    * I would like to use it to see the **amount of audience (big vs small)**     and the **dominance level of the audience (high vs low)** 
    * I will create a variable called **NAudience** to see hoy many individuals are in the audience for each trial
    * After calculating the elo ratings of the individuals using another dataset (Life history), I will create a dichotomic variable called **RankAudience** to see effects related to rank with the effect of audience
    
* **IDIndividual1**      : chr 
    "IDIndividual1" is coded in r as **character**
    * It gives the **names of the individuals that did not approach, showed aggression, distraction or lost interest** during a trial
    * I will have to look at it to see how often these behaviors occurred
    * I will consider how to use this variable during the cleaning of the data
    
* **IntruderID**         : chr 
    "IndtruderID" is coded as **character**
    * It gives the **name of the individual that did an intrusion during a trial**
    * Intrusion could mean, invade the space of the experiment and interact with one of our individual, steal the food, show agnostic behavior, stand in very close proximity of the other individual
    * I will have to check if there is a rule (ex. each intrsuion = no corn/tolerance, or if it depends from case to case)
    
* **Remarks**            : chr 
    The data is coded in r as **character**
    * It gives supplementary information concerning the experiment when unusual behaviors occurred or when we considered adding informations on the trial was necessary
    
* Observers               .chr
    The data is coded in r as **character**
    * It gives the **names of the observers during the experiment**
    * We will not use this data as we do not look at the effect that an experimenter would have on the monkeys
    * (Should I still look at an effect of the amount of experimenter?...maybe better for detailled analysis of our study)
    
* DeviceID             .chr
    "The data "DeviceID" is coded in r as **character**
    * It gives the **name of the device/tablet** used to record the data during the experiment
    * We will not use this data either
    
    


## 2. Cleaning the data

### Creating a new dataframe
* Since I do not want to work with the whole dataset, I'm gonna select the variables of interest using the function **select**

* I will keep Date, Group, MaleID, FemaleID, MaleCorn, Male placement corn, FemaleCorn, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks

```{r Bex Df, echo=FALSE} 
Bex<-Boxex%>%
  select(Date,Group, MaleID, FemaleID, MaleCorn,`Male placement corn`, FemaleCorn, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks )
glimpse(Bex)

View(Bex)
```

#### Merging Male placement corn and MaleCorn
* I want to process all the missing data in Bex. But before I will merge the column **MaleCorn** and **Male placement corn** as the data of both columns is supposed to be together under "MaleCorn"
* Looking manually in the Bex table it seems that very few data is in **MaleCorn** while most of it seems to be in **Male placement corn**
* Every time there is a missing value un Male placement corn we can see a value in Male Corn, I will then create a new variable MaleCorn where every time that there NA in male placement corn the value will be taken in MaleCornOld (previous malecorn). If there is no NA it will take the value of ´Male placement corn´
* I will first **rename MaleCorn to MaleCornOld**, then **check the amount of NA's** and then **merge "MaleCornOld" and "male placement corn"** into the **new variable "MaleCorn"**

```{r handling MaleCorn to MaleCornOld, include=FALSE}

# Check if the dataset has the necessary columns before proceeding 
if ("MaleCorn" %in% colnames(Bex) && "Male placement corn" %in% colnames(Bex)) {

  # Rename MaleCorn to MaleCornOld
  names(Bex)[names(Bex) == "MaleCorn"] <- "MaleCornOld"

  # Check the structure of Bex to confirm the changes
  str(Bex)

  # Check for missing values in MaleCornOld
  NA_MaleCornOld <- Bex[is.na(Bex$MaleCornOld) | is.na(Bex$`Male placement corn`), ]
  print(NA_MaleCornOld)

  # Check the intersection of rows with NA in MaleCornOld and Male placement corn
  Cross_NA <- Bex[is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`), ]
  View(Cross_NA)

  # Count the number of rows where both MaleCornOld and 'Male placement corn' have NA values
  common_na_count <- sum(is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`) & !is.na(Bex$MaleCornOld) & !is.na(Bex$`Male placement corn`))
  # Print the result
  cat("Number of rows with common NAs in MaleCornOld and 'Male placement corn':", common_na_count, "\n")

  # Check the amount of common NA between MaleCornOld and Male placement corn
  common_nas <- sum(is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`))
  print(common_nas)

  # Create a new variable MaleCorn
  Bex$MaleCorn <- ifelse(!is.na(Bex$MaleCornOld) | !is.na(Bex$`Male placement corn`), coalesce(Bex$MaleCornOld, Bex$`Male placement corn`), 0)
  
   # Count occurrences of 0 in MaleCorn
  zero_count <- sum(Bex$MaleCorn == 0)
  cat("Number of occurrences of 0 in MaleCorn:", zero_count, "\n")

  # Check the structure of Bex to confirm the changes
  str(Bex)

  # Remove the original MaleCornOld and Male placement corn
  Bex$MaleCornOld <- Bex$`Male placement corn` <- NULL

  # Check for missing values in the new MaleCorn
  NA_MaleCorn <- Bex[is.na(Bex$MaleCorn), ]
  print(NA_MaleCorn)

} else {
  # Display a message or take alternative actions if columns are missing
  cat("Error: Required columns not found in the dataset.\n")
}



```

* I have found **1499 NA in common** between MaleCornOld and 'male placement corn', **1609 NA in Male placement corn** and **2685 in MaleCorn old**


* For the **merge of MaleCornOld and Male placement corn**, I used different conditions:
  1.In this code, a new variable MaleCorn is created. If there is a missing value in Male placement corn, it takes the corresponding value from MaleCornOld; otherwise, it takes the value from Male placement     corn.
  2.If there are no value in both MaleCornOld and Male placement corn (NA,NA) for a given row, I would like the code to display 0 as it means that no placement was given
  
* In this way, I should not loose any data, minimize the mistakes and already transform the NA's of this variable into a number which will remove the remaining NA's which are meant to be 0
* After the merge I found that there were **no NA's remaining** in the **"New" Male Corn** and that **1499 0's** where found in the column which **corresponds to the amount of common NA's found previously** between the **"Old" Male Corn** and **male placement corn**

### Replacing and removing NA’S

#### Identifying variables with missing data

```{r Find Missing data, echo=FALSE}
# Check for missing data
missing_data <- sapply(Bex, function(x) sum(is.na(x)))

# Print missing data
cat("Variables with Missing Data:\n")
kable(missing_data[missing_data > 0])

cat("Variables with No Missing Data:\n")
kable(missing_data[missing_data == 0])
  
```

* We can see that out of the 13 variables we have in **Bex** we have **9 variables with missing data** which are **Male ID, Female ID, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks**

* I will proceeed to clean these variables one by one 

#### Cleaning "Remarks"
* Since most of the time we did not have any remarks it is understandable that this variable contains 2181 NA's out of 2795 rows
* I will first transform every missing data in the column Remark into **No Remarks** and then check that the amount of "No remarks" found are the same as the amount of NA's previously found
* After the changes we can effectively see that we have **2181 "No Remarks"** in this column

```{r Remarks NA, echo=FALSE}

# Replace NA's with "No Remarks" in the "Remarks" column
Bex$Remarks[is.na(Bex$Remarks)] <- "No Remarks"

# Check how many times "No Remarks" appears in the "Remarks" column
no_remarks_count <- sum(Bex$Remarks == "No Remarks")
cat("Number of 'No Remarks' in the 'Remarks' column:", no_remarks_count, "\n")

```

#### Cleaning "Intruder ID"
* Intruder ID is a variable that contains the name of the individuals that made and intrusion. If more than one individual intruded, his name may be in the comments, which I will check when treating the data from this column
* Because nothing was entered when there was no intrusion, I will replace every NA's by **No Intrusion**
* Also, I will use a function to create a new dichotomic variable called **Intrusion**. Every time there is a value in IntruderID, it should display 1 (Yes), if not a 0 (No intrusion)


```{r IntruderID NA, echo=FALSE}

# Replace NA's with "No Intrusion" in the "Intruder ID" column
Bex$IntruderID[is.na(Bex$IntruderID)] <- "No Intrusion"

# Create a new dichotomic variable called "Intrusion"
Bex$Intrusion <- ifelse(Bex$IntruderID == "No Intrusion", 0, 1)

# Check how many times "No Intrusion" appears in the "Intruder ID" column after replacement
no_intrusion_count <- sum(Bex$IntruderID == "No Intrusion")
cat("Number of 'No Intrusion' in the 'Intruder ID' column after replacement:", no_intrusion_count, "\n")

View(Bex)

```
* We previously had 2737 NA's in IntruderID while now we have the same amount of occurrences of IntruderID which shis that the transformation went as intended

#### Cleaning "IdIndividual1"

* IdIndividual1 is meant to report the name of the individual that did a behavior such as not approach, show aggression or loose interest during a trial
* I will now replace every NA in this column by No individual
* I also chose to directly create new dichotomic variables for "Not approaching", "Intrusion" (Used for double check), "Losing interest", "Distracted", for this I would like the function to
  1.Check if there is a value different than "No individual"
  2.If the value ≠"No individual" then I want it to take the response found in "DyadResposne" and if there are more than one value, report it in a new column called ">1 Response"
  
  
```{r IdIndividual1 NA, echo=FALSE}
  #Replace NA in IDindividual1 by No individual
  Bex$IDIndividual1[is.na(Bex$IDIndividual1)] <- "No individual"

# Create dichotomic variables
Bex$NotApproaching <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("Not approaching", Bex$DyadResponse), 1, 0)
Bex$Intrusion <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("Intrusion", Bex$DyadResponse), 1, 0)
Bex$LosingInterest <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("Losing interest", Bex$DyadResponse), 1, 0)
Bex$Distracted <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("Distracted", Bex$DyadResponse), 1, 0)

# Check for multiple responses
Bex$MultipleResponses <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("; ", Bex$DyadResponse), ">1 Response", "Single Response")


  
```
  
  

#### Cleaning "Audience"

#### Cleaning "OtherResponse"

#### Cleaning "DyadResponse"






#### Cleaning Female and Male ID

**Handling Missing Data:**

   - Checked for missing values in different Female and Male ID

    ``{r FemMal ID NA, echo=FALSE}
   
# Missing values in FemaleID
View(Bex[is.na(Bex$FemaleID), ])

# Missing values in MaleID
View(Bex[is.na(Bex$MaleID), ])
   
    ``

**Replacing Missing Values:**
   - Replaced missing values in `MaleID` and `FemaleID` columns with specified values.

   
    ``{r replace NA FemMalID, echo=FALSE} 
    
# Replaced missing values in MaleID and FemaleID columns with specified values.
replace_rows <- c(1699, 1700, ..., 2675)
Bex$MaleID[replace_rows] <- "Pom"
Bex$FemaleID[replace_rows] <- "Xian"
   
   
  # Checked and replaced NAs in specific rows and columns.
# Replace NAs in FemaleID based on row numbers
replace_rows <- c(865:879, 1827:1839, 1913:1914, 2665:2675)
Bex$FemaleID[replace_rows] <- c("Ndaw", "Sirk", "Oort", "Oerw")

    ``
    



   * I want to use the date to know **how many sessions** have been done with each dyads in my experiment. 
    * I will create a variable called **Session** where **1 session = 1 day**
    * The data has values from the **14th of September 2022** until the **13th of September 2023**
    * I may consider, in parallel of my hypothesis, to separate the data in *4 seasons* to make a preliminary check of a potential effect of seasonality. Nevertheless the fact that we did not use anywithout      tools to mesure the weather and the idea to make a categorization in 4 seasons without considering the actua quite arbitrary. I may do it but with no intention to include this in my scientific report.
    l temperature, food quantitiy and other elements related to seasonailty make this categorizationn a categorization where 12 months of          data will be separated in 4 categories
   


* But before I may want to make a few changes already by merging **Male corn** and **Male placement corn** into " Male corn" and maybe replacing all of the NA's in "Other response" by response







7. **Handling NAs in Specific Columns:**
   - Checked and replaced NAs in specific rows and columns.

    ```{r replace NA FemID, echo=FALSE} 
   # Replace NAs in FemaleID based on row numbers
   replace_rows <- c(865:879, 1827:1839, 1913:1914, 2665:2675)
   Bex$FemaleID[replace_rows] <- c("Ndaw", "Sirk", "Oort", "Oerw")
    ```

8. **Replacing NAs in Male Corn with 0:**
   - Replaced NAs in `MaleCorn` and `FemaleCorn` columns with 0.

    ```{r replace NA Male Corn, echo=FALSE} 
   Bex$MaleCorn[is.na(Bex$MaleCorn)] <- 0
   Bex$FemaleCorn[is.na(Bex$FemaleCorn)] <- 0
    ```
   

9. **Resolving Issues:**
   - Discussed and resolved various issues related to data import, formatting, and error messages.

10. **Printing Summary:**
    - Provided a summary of the steps and code snippets for reference.

Please note that the code snippets may need to be adapted to your specific data and requirements. Let me know if you have any specific questions or if there's anything else you'd like assistance with!




#########

# Glossary
* **Tolerance**: Tolerance: An individual has an encounter with a conspecific and
  can freely leave but remains in the encounter without acting aggressively
  toward the conspecific. (Pisor & Surbeck, 2019)
* **Agression**
* **Session** 
* **Trial**
* **Group**: In the Primate order, groups are individuals “which remain [physically] together in or separate from a larger unit” and interact with each other more than with other individuals.6 This            definition does not cover all uses of the word “group” in the social sciences (e.g., human identity groups who identify with a common name or symbol may or may not interact with one another more frequently   than with other individuals). Because of this ambiguity, we use the word “community” when referring to humans to better capture the notion of spatial proximity, per Ref. 54. Members of the same group are    referred to as “same-group” and those from another group “extra-group.” (Pisor & Surbeck, 2019)


# Bibliography
 •	Pisor, A. C., & Surbeck, M. (2019). The evolution of intergroup tolerance in nonhuman primates and humans. Evolutionary Anthropology: Issues and Reviews. Advance online publication. https://doi.org/10.1002/evan.21793
(Pisor & Surbeck, 2019)



# Annex

#### Annex 1 : View of the dataset when imported - First 6 entries of each variable 
* We can see here the brief view of the **original dataset** names **BoxEx**when i initially imported it as seen in **section 0: Opening data** 



```{r View of the data Boxex, echo=FALSE}

# Display the original dataset that is name Boxex
pander(head(Boxex), style = "rmarkdown", caption = "First Few Entries") 

```