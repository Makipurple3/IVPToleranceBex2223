---
title: "BEX 2223 MAungKyaw"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
# Set global knitr options
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction


## 0.Opening the data
### Loading data

```{r LoadData, include=FALSE}

# Load knitr for  markdown outputs
library(knitr)

##Load pander for better presentation of the outputs
library(pander)

##Load dplyr for better manipulation of the data
library(dplyr)

# Load readxl package to import the data
library("readxl")

# Load Lubridate fort better date and time manipulation
library(lubridate)

# Read xlsx files
Boxex <- read_xls("/Users/maki/Desktop/Master Thesis/BEX 2223 Master Thesis MAung Kyaw/Makipurple3/Box Experiments.xls")

``` 

* First I downloaded the **knitr package** to create outputs as html, pdf or word files when knitting my r markdown file. I also loaded nd the **pander** package for better presentation
* The **dplyr** package was installed for better manipulation of the data as filtering or creating new variables and **lubridate** for a better manipulation of dates and time
* Then, I installed the **readxl package** to import my dataset which is called **Box Experiments.xls**
* This dataset contains information related to my master thesis project. I used cyber tracker in order to record the behaviors of dyads of Vervet monkeys in a box experiment on tolerance from September 2022 to September 2023

## 1.Explore the data

### Description of the initial datset - "Boxex"

```{r View and Glimpse of Boxex, echo=FALSE}

# First view of my datset
View(Boxex)

#GLimpse function to see the summary and  the structure

cat("Glimpse of the the Box Experiment dataset:\n\n")
glimpse(Boxex)
```



* I am now using the **view** function to have a sight on the entire dataset and **glimpse** to display a summary of my dataset
* I have **20 columns** (here variables) and **2795 rows** (here trials)

* I will now make a brief summary of each variables and their use before creating a new dataframe (df) with my variables of interest that I will call **Bex**

* The highlighted variables are the ones I will use for **Bex**. I will then **clean the data**  before heading to the **statistical analysis** and the **interpretation of the results*


#### Variables of Boxex

* **Date**               :
    "Date" is in ac**POSIXct** format which is appropriate for the display of time 

    * I want to use the date to know **how many sessions** have been done with each dyads in my experiment. 
    * I will create a variable called **Session** where **1 session = 1 day**
    * The data has values from the **14th of September 2022** until the **13th of September 2023**
    * I may consider separating the **12 months** of data in **4 seasons** to make a preliminary check of a potential effect of seasonality. Nevertheless we did not use any tools to measure the weather,         temperature, humidity or food availability (also related to seasonality and weather). Categorizing my data in 4 without having further data would then be quite arbitrary. If I end up doing it in my          report, it will be done without any intention to include it in scientific analysis nor my scientific report .
    

    
* **Time**                  : 
     "Time is coded" in a **POSIXct** format 
     
    * I do not plan to use this variable but we can see that "Time" has hours displayed with a date which is incorrect. 
    * (In the case I wanted to observe **when the trials occurred during the day** as time may have an influence on their behavior) **SOURCE**I would need to correct the incorrect display of the date in the dataset.
    * This variable could also be useful to see when  the **seasonal effect** took place as we only went in the morning during summer because of the heat while we went later and for longer times in the          field to do the box experiment in winter 
    * For now, the values in "Time" are all on the same (wrong) day which is the **31st  of December** 
    * Note: I first did not intend to keep **Time** in Bex but I needed this variable to see the order of the trails within a day. I finally decided to keep it.
    
* Data                   : chr 
    "Data" is coded as **character**
    * It describes **the type of data** being recorded in the software **cybertracker**. We installed the software on tablets to record the different behaviors of vervet monkeys in our research center
    * In our case, my data was recorded in cybertracker as **Box Experiment** as we created a form specifically for this experiment
    * For this reason we can remove this column as the information is unecessary
      
* Group             : chr 
    The data is coded in r as a **character**
    * It describes the **group of monkey** in which we did the trial
    * I will keep this column to see theamount of trials that we did in the 3 group of monkeys which are Baie-Dankie **(BD)**, Ankhase **(AK)**, and Noha **(NH)**
      
* GPSS                   : num 
    "GPSS" is coded as **numerical**
    * It gives the **south coordinates** in which we started the experiment
    * I do not plan to use coordinates nor look at locations so I will remove this acolumn
    
* GPSE                   : num 
    "GPSE" is coded in as **numerical**
    * It gives the **east coordinates** in which we started the experiment
    * I do not plan to use coordinates nor look at locations so I will remove this column
  
* **MaleID**             : chr 
    "MaleID" is coded as **character**
    * It gives the **name of the male involved in the trial**
    * I plan to use this to see how factors related to the individual may influence the            experiment (age, sex, rank)
    * It will also help me see which behaviour was displayed by each individuals (here males)
  
  
* **FemaleID**           : chr
    "FemaleID" is coded as **character**
    * It gives the **name of the female involved in the trial**
    * I plan to use this variable in the same way as "Male ID"
    * It will also help me see which behaviour was displayed by each individuals (here females)
    
* **Male placement corn**: dbl
    "Male placement corn is coded in r as **double**
    * It gives the **amount of corn given to the monkey of the dyad before the trials**
    * Within a session it happened that we gave more placement corn to attract the monkeys again to the boxes. This lead to an update of the number in the same session. The number found at the end of the         session is the total placement corn an individual has received
    * I will fuse this column with **male corn***as the data has been separated between these two variables. This is due to a mistake when creating the original box experiment form in cybertracker
    
    * This variable could be related to the level of motivation of a monkey but as it is not directly related to my hypothesis I may not use this column. I will re-consider the use of this column later on
    * In regards of this possibility I will change the format of the variable to numerical 
  
* **MaleCorn**           : dbl
    "MaleCorn" is coded in r as **double**
    * It gives the same information as in ***male placement corn***
    * I will import the values from "male placement corn" into this one
    * I will change the format of the variable to numerical 
    
    
* **FemaleCorn**         : dbl
    The data is coded in r as **double**
    * It gives the **amount of corn given to the monkey before the trials**
    * It works in the same way as "male placement corn"/"MaleCORN"
    * I will change the format of the varaible to numerical 
  
  
* **DyadDistance**       : chr 
    The data is coded in r as **character**
    * I gives the **distance for each trial** we have done with the dyads. 
    * The trial number 1 for each dyad was at 5 meters. 
    * The maximum was around 10 m while the minimum is 0
    * We will have to remove the "m" for meters in order to have a numerical variable insterad of character
    
  
* **DyadResponse**       : chr 
    The data is coded in r as **character**
    * It gives the code of **the behaviour produced by each dyad per trial**
    * The different behaviours were: **Distracted**, **Female aggress male**, **Male aggress female**, **Intrusion**, **Loosing interest**, **Not approaching**, **Tolerance** and **Other**
    * I will change the columns associated to each behavior (i.e. Response) of  **DyadResponse**    into dichotomic variables in order to see the frequency of each behaviour
    * This will allow me to see which behavior occured more than others, and what differences are between dydads 
    * As multiple response could occur within the same trial, multiple behaviors can be found in a single cell. I will create a  hierarchy to reduce the amount of behaviors assigned to each trial (if  there     is more than one). This will also be complemented with the information found in the column comments
      1. correct any mistakes (ex. if tolerance and aggression are together aggression>tolerance)
      2. assign as few labels per trial 
      3. get a better view and understanding of the data and the most common behaviours produced by each dyad
      4. create variables that can complement the behaviour found (ex. not approaching + looks at partner would be looks at partner + a new variable called hesistant to see when the did not come but look at         the other individual / )
      
    * Projection of the hierarchy (changes will be made)
      - Create a table with each combination existing
      
      - Decide what is more important
      - Ex:
        - Aggression > Tolerance
        - Tolerance > Not approaching -> Create a variable called hesistant in         addtion to the tolerance count to see frequency of tolerance                 behaviour that happened after > 1min
        - Tolerance > Loosing interest
        - Tolerance > Intrusion
        - Not approaching = looking box but not coming while Loosing interest           = not paying attention to the box
        - Intrusion > Loosing interest
        - Intrusion > Not approaching
        - Not approaching > Looks at partner
        - We can code every look at partner as no approaching and keep the             count of looks at partner as additional information
        - Not approaching >?> Loosing interest ? !!
        - Define distracted
        - Not approaching > Distracted
        - Aggression > Not approaching
        - Other > Look case by case and categorize depending of behavior
        - Remarks may be used for the same reason
        
  
* **OtherResponse**      : chr 
    "The data"OtherResponse" is coded as **character**
    * It describes **Any behaviour that is not included in the  ones from Dyad Response**     (meaning ≠ tolerance, aggression, intrusion, loosing interest, not approaching, distracted)
    * I will have to look at every **OtherResponse** and rename each entry in one of the response already if exstiting. I will proceed case by case.
    * If I want to do an intermediate manipulation I may rename every NA in "OtherResponse" into **Response** to see the amount of case to treat and how many occurences seem to not fit in the categories of        "DyadResponse"
    
* **Audience**      : chr 
    "Audience" is r as **character**
    * It gives the **names of the individuals in the audience**
    * I would like to use it to see the **amount of audience (big vs small)**     and the **dominance level of the audience (high vs low)** 
    * I will create a variable called **NAudience** to see hoy many individuals are in the audience for each trial
    * After calculating the elo ratings of the individuals using another dataset (Life history), I will create a dichotomic variable called **RankAudience** to see effects related to rank with the effect of audience
    
* **IDIndividual1**      : chr 
    "IDIndividual1" is coded in r as **character**
    * It gives the **names of the individuals that did not approach, showed aggression, distraction or lost interest** during a trial
    * I will have to look at it to see how often these behaviors occurred
    * I will consider how to use this variable during the cleaning of the data
    
* **IntruderID**         : chr 
    "IndtruderID" is coded as **character**
    * It gives the **name of the individual that did an intrusion during a trial**
    * Intrusion could mean, invade the space of the experiment and interact with one of our individual, steal the food, show agnostic behavior, stand in very close proximity of the other individual
    * I will have to check if there is a rule (ex. each intrsuion = no corn/tolerance, or if it depends from case to case)
    
* **Remarks**            : chr 
    The data is coded in r as **character**
    * It gives supplementary information concerning the experiment when unusual behaviors occurred or when we considered adding informations on the trial was necessary
    
* Observers               .chr
    The data is coded in r as **character**
    * It gives the **names of the observers during the experiment**
    * We will not use this data as we do not look at the effect that an experimenter would have on the monkeys
    * (Should I still look at an effect of the amount of experimenter?...maybe better for detailled analysis of our study)
    
* DeviceID             .chr
    "The data "DeviceID" is coded in r as **character**
    * It gives the **name of the device/tablet** used to record the data during the experiment
    * We will not use this data either
    
    

## 2. Cleaning the data

### Creating a new dataframe
* Since I do not want to work with the whole dataset, I'm gonna select the variables of interest using the function **select**

* I will keep Date, Group, MaleID, FemaleID, MaleCorn, Male placement corn, FemaleCorn, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks

```{r Bex Df, echo=FALSE} 
Bex<-Boxex%>%
  select(Time,Date,Group, MaleID, FemaleID, MaleCorn,`Male placement corn`, FemaleCorn, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks )
glimpse(Bex)

View(Bex)
```

#### 2.0.1 Merging Male placement corn and MaleCorn
* I want to process all the missing data in Bex. But before I will merge the column **MaleCorn** and **Male placement corn** as the data of both columns is supposed to be together under "MaleCorn"
* Looking manually in the Bex table it seems that very few data is in **MaleCorn** while most of it seems to be in **Male placement corn**
* Every time there is a missing value un Male placement corn we can see a value in Male Corn, I will then create a new variable MaleCorn where every time that there NA in male placement corn the value will be taken in MaleCornOld (previous malecorn). If there is no NA it will take the value of ´Male placement corn´
* I will first **rename MaleCorn to MaleCornOld**, then **check the amount of NA's** and then **merge "MaleCornOld" and "male placement corn"** into the **new variable "MaleCorn"**

```{r handling MaleCorn to MaleCornOld, include=FALSE}

# Check if the dataset has the necessary columns before proceeding 
if ("MaleCorn" %in% colnames(Bex) && "Male placement corn" %in% colnames(Bex)) {

  # Rename MaleCorn to MaleCornOld
  names(Bex)[names(Bex) == "MaleCorn"] <- "MaleCornOld"

  # Check the structure of Bex to confirm the changes
  str(Bex)

  # Check for missing values in MaleCornOld
  NA_MaleCornOld <- Bex[is.na(Bex$MaleCornOld) | is.na(Bex$`Male placement corn`), ]
  print(NA_MaleCornOld)

  # Check the intersection of rows with NA in MaleCornOld and Male placement corn
  Cross_NA <- Bex[is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`), ]
  View(Cross_NA)

  # Count the number of rows where both MaleCornOld and 'Male placement corn' have NA values
  common_na_count <- sum(is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`) & !is.na(Bex$MaleCornOld) & !is.na(Bex$`Male placement corn`))
  # Print the result
  cat("Number of rows with common NAs in MaleCornOld and 'Male placement corn':", common_na_count, "\n")

  # Check the amount of common NA between MaleCornOld and Male placement corn
  common_nas <- sum(is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`))
  print(common_nas)

  # Create a new variable MaleCorn
  Bex$MaleCorn <- ifelse(!is.na(Bex$MaleCornOld) | !is.na(Bex$`Male placement corn`), coalesce(Bex$MaleCornOld, Bex$`Male placement corn`), 0)
  
   # Count occurrences of 0 in MaleCorn
  zero_count <- sum(Bex$MaleCorn == 0)
  cat("Number of occurrences of 0 in MaleCorn:", zero_count, "\n")

  # Check the structure of Bex to confirm the changes
  str(Bex)

  # Remove the original MaleCornOld and Male placement corn
  Bex$MaleCornOld <- Bex$`Male placement corn` <- NULL

  # Check for missing values in the new MaleCorn
  NA_MaleCorn <- Bex[is.na(Bex$MaleCorn), ]
  print(NA_MaleCorn)

} else {
  # Display a message or take alternative actions if columns are missing
  cat("Error: Required columns not found in the dataset.\n")
}



```

* I have found **1499 NA in common** between MaleCornOld and 'male placement corn', **1609 NA in Male placement corn** and **2685 in MaleCorn old**


* For the **merge of MaleCornOld and Male placement corn**, I used different conditions:
  1.In this code, a new variable MaleCorn is created. If there is a missing value in Male placement corn, it takes the corresponding value from MaleCornOld; otherwise, it takes the value from Male placementcorn.
  2.If there are no value in both MaleCornOld and Male placement corn (NA,NA) for a given row, I would like the code to display 0 as it means that no placement was given
* In this way, I should not loose any data, minimize the mistakes and already transform the NA's of this variable into a number which will remove the remaining NA's which are meant to be 0
* After the merge I found that there were **no NA's remaining** in the **"New" Male Corn** and that **1499 0's** where found in the column which **corresponds to the amount of common NA's found previously** between the **"Old" Male Corn** and **male placement corn**


###2.1 Replacing and removing NA’S

#### 2.1.2 Identifying variables with missing data

* Now in order to see where are located the missing points in the data, I'm going to **print** the variables **with and without NA's**

* The function **sapply** is used to apply the function **sum** for NA's to each column of the data frame, so each variable

```{r Find Missing data, echo=FALSE}
# Check for missing data
missing_data <- sapply(Bex, function(x) sum(is.na(x)))

# Print missing data
cat("Variables with Missing Data:\n")
kable(missing_data[missing_data > 0])

cat("Variables with No Missing Data:\n")
kable(missing_data[missing_data == 0])
  
```

* We can see that out of the 13 variables we have in **Bex** we have **9 variables with missing data** which are **Male ID, Female ID, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks**

* I will proceeed to clean these variables one by one 

#### 2.3 Cleaning "Remarks"
* Since most of the time we did not have any remarks it is understandable that this variable contains 2181 NA's out of 2795 rows
* I will first transform every missing data in the column Remark into **No Remarks** and then check that the amount of "No remarks" found are the same as the amount of NA's previously found
* After the changes we can effectively see that we have **2181 "No Remarks"** in this column

```{r Remarks NA, echo=FALSE}

# Replace NA's with "No Remarks" in the "Remarks" column
Bex$Remarks[is.na(Bex$Remarks)] <- "No Remarks"

# Check how many times "No Remarks" appears in the "Remarks" column
no_remarks_count <- sum(Bex$Remarks == "No Remarks")
cat("Number of 'No Remarks' in the 'Remarks' column:", no_remarks_count, "\n")

```

#### 2.4 Cleaning "Intruder ID"
* Intruder ID is a variable that contains the name of the individuals that made and intrusion. If more than one individual intruded, his name may be in the comments, which I will check when treating the data from this column
* Because nothing was entered when there was no intrusion, I will replace every NA's by **No Intrusion**
* Also, I will use a function to create a new dichotomic variable called **Intrusion**. Every time there is a value in IntruderID, it should display 1 (Yes), if not a 0 (No intrusion)


```{r IntruderID NA, echo=FALSE}

# Replace NA's with "No Intrusion" in the "Intruder ID" column
Bex$IntruderID[is.na(Bex$IntruderID)] <- "No Intrusion"

# Create a new dichotomic variable called "Intrusion"
Bex$Intrusion <- ifelse(Bex$IntruderID == "No Intrusion", 0, 1)

# Check how many times "No Intrusion" appears in the "Intruder ID" column after replacement
no_intrusion_count <- sum(Bex$IntruderID == "No Intrusion")
cat("Number of 'No Intrusion' in the 'Intruder ID' column after replacement:", no_intrusion_count, "\n")

```
* We previously had 2737 NA's in IntruderID while now we have the same amount of occurrences of IntruderID which shis that the transformation went as intended

#### 2.5 Cleaning "IdIndividual1"

* IdIndividual1 is meant to report the name of the individual that did a behavior such as not approach, show aggression or loose interest during a trial
* I will now replace every NA in this column by No individual
* I also chose to directly create new dichotomic variables for "Not approaching", "Intrusion" (Used for double check), "Losing interest", "Distracted", for this I would like the function to
  1.Check if there is a value different than "No individual"
  2.If the value ≠"No individual" then I want it to take the response found in "DyadResposne" and if there are more than one value, report it in a new column called ">1 Response"
  
  
```{r IdIndividual1 NA, echo=FALSE}
  #Replace NA in IDindividual1 by No individual
  Bex$IDIndividual1[is.na(Bex$IDIndividual1)] <- "No individual"

# Create dichotomic variables
Bex$NotApproaching <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("Not approaching", Bex$DyadResponse), 1, 0)
Bex$Intrusion <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("Intrusion", Bex$DyadResponse), 1, 0)
Bex$LosingInterest <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("Losing interest", Bex$DyadResponse), 1, 0)
Bex$Distracted <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("Distracted", Bex$DyadResponse), 1, 0)

# Check for multiple responses
Bex$MultipleResponses <- ifelse(Bex$IDIndividual1 != "No individual" & grepl("; ", Bex$DyadResponse), ">1 Response", "Single Response")

```
  

#### 2.6 Cleaning "Audience"
* Audience is made to report every name of individuals around our dyad during a given trial
* I will replace every NA by **No audience** as no entry means the absence of other individuals around
* I will also create a new variable called "Amount audience" that will have to tell me how many individuals are found in the column Audience 

```{r Audience NA, echo=FALSE}
#Creating amount of audience
Bex$AmountAudience <- ifelse(is.na(Bex$Audience), 0, lengths(strsplit(Bex$Audience, "; ")))

#Changing NA's in No audience
Bex$Audience[is.na(Bex$Audience)] <- "No audience"

```


#### 2.7 Cleaning "OtherResponse"
```{r OtherResposne NA, echo=FALSE}
# Replace NA in OtherResponse by "No Response"
Bex$OtherResponse[is.na(Bex$OtherResponse)] <- "No Response"

```


#### 2.8 Cleaning of "Time"
* Since the reading of the data is more complicated without the time, which was usefull to know which trial was before or after, I changed the code made for Bex and added **Time** in the dataframe. Since I will need it for the cleaning of Dyaddistance, I will treat it now

```{r Time, include=FALSE}

# Assuming Bex is your dataframe
# Convert 'Time' to POSIXct format
Bex$Time <- as.POSIXct(Bex$Time, format = "%Y-%m-%d %H:%M:%S")

# Extract only the time from 'Time' and assign it update Time'
Bex$Time <- format(Bex$Time, "%H:%M:%S")


```


#### 2.9 Cleaning DyadDistance
* Before looking at the NA's of Dyaddistance I will remove the "m" that is in front of every number to      have a numerical variable
* Then I will look at the location of the NA's in the data to treat them case by case.


```{r DyadDistance NA, echo=FALSE}

# Check if the dataset has the necessary columns before proceeding 
if ("DyadDistance" %in% names(Bex)) {

  # Check if modifications are needed (avoiding unnecessary changes on multiple runs)
  if (!all(grepl("^\\d+$", as.character(Bex$DyadDistance)))) {
    
    # Remove "m" from DyadDistance and convert to numeric
    Bex$DyadDistance <- as.numeric(gsub("m", "", Bex$DyadDistance), errors = "coerce")
    
    # Identify NA values in DyadDistance
    NA_DyadDistance <- Bex[is.na(Bex$DyadDistance), ]
    
    # View the locations of NA values
    View(NA_DyadDistance)
    
    # Count the number of missing values in the DyadDistance column
    dyad_distance_missing_data <- Bex[is.na(Bex$DyadDistance), ]
    
    # Print the result
    cat("Number of NA values in DyadDistance column (using second approach):", nrow(dyad_distance_missing_data), "\n")
    
    # Find row indices with NA values in DyadDistance
    dyad_distance_na_row <- which(is.na(Bex$DyadDistance))
    
    # Print the row indices
    cat("Rows with NA values in DyadDistance column:", paste(dyad_distance_na_row, collapse = ", "), "\n")

  } else {
    cat("No modifications needed for DyadDistance. It already appears to be in the desired format.\n")
  }

} else {
  # Display a message or take alternative actions if columns are missing
  cat("Error: Required columns not found in the dataset.\n")
}

```



* We have 69 missing values in  DyadDistance. I will look at each row in it's context as the actual distance of the box was always dependent of the previous trials. I will start with the bigger number as for now the oldest trial is at the last row while the closest one is in row 1.



  - If **tolerance** was achieved **twice in a row**     =   <1m
  - If **aggression** (male agress female or female agress male), not approaching,or **loosing     interest** occured                                   =   >1m
  - If **distracted** or **intrusion** occured           =    same distance
  
  1. **24** - In trial23 (0m) there was aggression then at trial24 (1m) there was tolerance. The 24th trial is supposed to be at **1m**
  2. **27** - In trial25 (1m) there was not approaching then at trial26 (2m) there was tolerance.The 25th trial is supposed to be at **2m**
  3. **95** - In trial93 (2m ) there was male agress female then at trial 94 (3m) there was not approaching. The 95th trial is supposed to be at **4m**
  4. **492** - In trial490 (0m) there was tolerance then at trial491 (0m) there was tolerance. The 492nd trial is supposed to be at **0m**
  5. **744** - In trial742 (3m) there was aggression then at trial743 (4m) there was tolerance. The 744th trial is supposed to be at **4m**    
  6. **971** - In trial969 (0m) there was tolerance then at trial970 (0m) there was tolerance. The 971st trial is supposed to be at **0m**
  7. **1113** - In trial1111 (2m) there was tolerance then at trial1112 (0m) there was tolerance. The 1113th trial is supposed to be at **0m**
  8. **1130** - In trial1128 there was another dyad so we can not use this cell. Then at trial1129 (3m) there was not approaching. Nevertheless, we don't have any DyadResponse, i will thus **delete this row** 
  9. **1164** - In trial1162 (3m) there was not approaching then at trial1163 (3m) there was not approaching. The 1164th trial is supposed to be at **4m**
  10. **1261** - The two
  preivous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  11. **1341** - In trial1339 (0m) there was tolerance then at trial1340 (0m) there was tolerance. The 1341st trial is supposed to be at **0m**
  12. **1396** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  13. **1491** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  14. **1583** - In trial1581 (2m) there was not approaching and intrusion then at trial1582 (2m) there was not approaching. The 1583rd trial is supposed to be at **3m**
  15. **1683** - One trial only was made with tolerance (2m) but since there are no DyadResponse I will **delete this row**
  16. **1693** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  17. **1717** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  18. **1718** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  19. **1719** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  20. **1724** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  21. **1725** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  22. **1739** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  23. **1755** - since there are no DyadResponse I will **delete this row**
  24. **1756** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  25. **1757** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  26. **1764** - Since there are no DyadResponse I will **delete this row**
  27. **1779** - It seems like it was the first trial of the Dyad Pom Xian, if so, the distance has to be **5m**
  28. **1782** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  29. **1792** - Trial1791 was intrusion (4m) so this trial should be at **4m**
  30. **1799** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  31. **1800** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  32. **1840** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  33. **1841** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  34. **1868** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  35. **1869** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  36. **1888** - he two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  37. **1891** - Since there are no DyadResponse I will **delete this row**
  38. **1892** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  39. **1896** - Since there are no DyadResponse I will **delete this row**
  40. **1911** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  41. **1912** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  42. **1915** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  43. **1918** - In trial1916 (4m) there was tolerance then at trial1917 (4m) there was not loosing interest The 1918th trial is supposed to be at **4m**
  44. **1919** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  45. **1952** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  46. **1953** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  47. **1958** - In trial1956 (2m) there was tolerance then at trial1957 (2m) there was distracted. The 1958th trial is supposed to be at **2m**
  48. **1980** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  49. **1981** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  50. **1984** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  51. **1986** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  52. **1996** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  53. **2000** - In trial1997 and 1999 (5m) there was tolerance then at trial1999 (5m) there was intrusion. The 2000th trial is supposed to be at **4m**
  54. **2009** - Since there are no DyadResponse I will **delete this row**
  55. **2054** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  56. **2104** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  57. **2105** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  58. **2191** - In trial2189 (1m) there was not approaching then at trial2190 (2m) there was not approaching. The 2191st trial is supposed to be at **3m**
  59. **2233** - In trial2231 (3m) there was not approaching then at trial2232 (4m) there was not approaching. The 2233rd trial is supposed to be at **5m**
  60. **2234** - The trial did not happen because they where not at the right distance. I will thus **delete this row**
  61. **2287** - Since there are no DyadResponse I will **delete this row**
  62. **2437** - Since there are no DyadResponse I will **delete this row**
  63. **2569** - In trial2567 (1m) there was tolerance then at trial2568 (1m) there was tolerance. The 2569th trial is supposed to be at (0m)
  64. **2579** - In trial2577 (1m) there was tolerance then at trial2578 (0m) there was not approaching. The 2579th trial is supposed to be at **1m**
  65. **2580** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  66. **2643** - Since there are no DyadResponse I will **delete this row**
  67. **2676** - In trial2674 (1m) there was tolerance then at trial2675 (0m) there was tolerance. The 2676th trial is supposed to be at **0m**
  68. **2709** - In trial2707 (2m) there was tolerance then at trial2708 (2m) there was tolerance. The 2709th trial is supposed to be at **1m**
  69. **2729** - In trial2727 (3m) there wastolerance then at trial2728 (2m) there was tolerance. The 2729th trial is supposed to be at **2m**


* Now that I have looked at each missing line and saw which ones to keep, I decided to create a new variable called **Distance**. I will also to create a new variable called **No trial**.
* For the variable **Distance** I will replace each row where there was missing data with a value and I will delete the ones where no values could be assigned. This will allow me to have no missing data and find a number to each trial that has been done
 
```{r Distance, echo=TRUE}
# Check if the dataset has the necessary columns before proceeding 
if ("DyadDistance" %in% names(Bex)) {

  # Check if the modification has already been applied
  if (!all(c("Dyadistance", "Distance") %in% names(Bex))) {
    
    # Define replacement values
    replacement_values <- c(
      `24` = 1, `27` = 2, `95` = 4, `492` = 0, `744` = 4, `971` = 0, `1113` = 0, `1164` = 4,
      `1341` = 0, `1583` = 3, `1779` = 5, `1792` = 4, `1840` = 0, `1868` = 0, `1918` = 4,
      `2000` = 4, `2191` = 3, `2233` = 5, `2569` = 0, `2579` = 1, `2676` = 0, `2709` = 1, `2729` = 2
    )
    
    # Applying rules to update DyadDistance
    Bex <- Bex %>%
      mutate(
        Dyadistance = ifelse(row_number() %in% names(replacement_values), replacement_values[as.character(row_number())], DyadDistance)
      )
    
    # Create a new variable Distance with values from DyadDistance
    Bex <- Bex %>% mutate(Distance = DyadDistance)
    
    # Count NA's in Distance
    na_count <- sum(is.na(Bex$Distance))
    print(paste("Number of NA's in Distance: ", na_count))
    
    # Remove rows with NA in Distance after replacing values 
    Bex <- Bex %>% filter(!is.na(Distance))
    
    # Count NA's in Distance after removing NA's
    na_count <- sum(is.na(Bex$Distance))
    print(paste("Number of NA's in Distance: ", na_count))
    
  } else {
    # Display a message if the modifications have already been applied
    cat("Modification already applied. No changes made.\n")
  }

} else {
  # Display a message or take alternative actions if columns are missing
  cat("Error: Required columns not found in the dataset.\n")
}

```
*In this modification, I added a check to see if the columns Dyadistance and Distance already exist in your dataframe (Bex). If they do, it prints a message saying that the modification has already been applied, and no changes are made. If they don't exist, it proceeds with the modifications. This way, running the code multiple times won't cause redundant changes.
  
* **23 values** were inserted in **Distance** to replace the NA's where the distance could be found by looking at the previous rows. The **46 remaining NA's** were then **removed** from Distance **leaving 0 NA in Distance**

* Now I would like to create a dichotomic variable called **No trial** that will use the rows that I deleted in Distance. I would like this column to put 1 for every trial that was deleted from Distance. I will later on look again at this column. 
* I decided to this since I remebered that the lines where we could not assign any distance happened when the monekys where
 1. The dyad was not close enough to do the experiment 
 2. We had another dyad at proximity that we were more interested or that was easier to test
I will use this variable to look at the cases where this happen. at term I will not use this variable in my analysis

```{r No Trial, include=FALSE}

# Identify rows to delete based on the rules
rows_to_delete <- c(24, 27, 95, 492, 744, 971, 1113, 1130, 1164, 1261, 1341, 1396, 1491, 1583, 1683, 1693, 1717, 1718, 1719,
                    1724, 1725, 1739, 1755, 1756, 1757, 1764, 1779, 1782, 1792, 1799, 1800, 1840, 1841, 1868, 1869, 1888, 1891,
                    1892, 1896, 1911, 1912, 1915, 1919, 1952, 1953, 1958, 1980, 1981, 1984, 1986, 1996, 2000, 2009, 2054, 2104,
                    2105, 2191, 2233, 2234, 2287, 2437, 2569, 2579, 2580, 2643, 2676, 2709, 2729)

# Create NoTrial variable
Bex$NoTrial <- ifelse(seq_along(Bex$Distance) %in% rows_to_delete, 1, 0)

```




#### 2.10 Cleaning Female and Male ID

* Before cleaning here are all the dyads that were present during the experiment. This will help us find the missing names when only one ID is missing (either male or female):
  a. Sirk & Sey - BD
  b. Ouli & Xin - BD
  c. Piep & Xia - BD
  d. Oerw & Nge - BD
  e. Oort & Kom - BD
  
  f. Ginq & Sho - AK
  g. Ndaw & Buk - Ak
  
  h. Xian & Pom - AK
  i. Guat & Pom - Ak
* First I have to check where are the NA's in both FemaleID and Male ID by looking at the rows where data is missing. Since every trial was made with a Dyad, trating these two columns together makes more sense. 


```{r FemaleMaleID NA, echo=FALSE}

# Replace all NA values in MaleID and FemaleID with NA
Bex <- Bex %>%
  mutate(
    MaleID = ifelse(is.na(MaleID), NA, MaleID),
    FemaleID = ifelse(is.na(FemaleID), NA, FemaleID)
  )

# Checking for amount of  missing values in FemaleID and MaleID

# Missing values in FemaleID
female_missing_rows <- which(is.na(Bex$FemaleID))
View(Bex[female_missing_rows, ])
cat("Number of missing values in FemaleID: ", sum(is.na(Bex$FemaleID)), "\n")

# Missing values in MaleID
male_missing_rows <- which(is.na(Bex$MaleID))
View(Bex[male_missing_rows, ])
cat("Number of missing values in MaleID: ", sum(is.na(Bex$MaleID)), "\n")

   
# Checking for location of missing values in FemaleID and MaleID

# Missing values in FemaleID
female_missing_rows <- which(is.na(Bex$FemaleID))
cat("Row numbers with missing values in FemaleID: ", female_missing_rows, "\n")
cat("Number of missing values in FemaleID: ", length(female_missing_rows), "\n")

# Missing values in MaleID
male_missing_rows <- which(is.na(Bex$MaleID))
cat("Row numbers with missing values in MaleID: ", male_missing_rows, "\n")
cat("Number of missing values in MaleID: ", length(male_missing_rows), "\n")



# Check where we have Na in both Female and Male ID  and in whcih rows
# Row numbers with missing values in both FemaleID and MaleID
both_missing_rows <- which(is.na(Bex$FemaleID) & is.na(Bex$MaleID))

# Count of rows with missing values in both FemaleID and MaleID
both_missing_count <- length(both_missing_rows)

cat("Number of rows with missing values in both FemaleID and MaleID: ", both_missing_count, "\n")
cat("Row numbers with missing values in both FemaleID and MaleID: ", toString(both_missing_rows), "\n")


# Rows with missing values in FemaleID but not in MaleID
only_female_missing_rows <- setdiff(female_missing_rows, both_missing_rows)

# Count of rows with missing values only in FemaleID
only_female_missing_count <- length(only_female_missing_rows)

cat("Number of missing values in FemaleID not in MaleID: ", only_female_missing_count, "\n")
cat("Row numbers with missing values in FemaleID not in MaleID: ", toString(only_female_missing_rows), "\n")



```
    
    
* **FemaleID** has **44 NA's** while they are **18 NA's** in **Male ID**
* In these missing data, we have **18 NA's** that are in common between FemaleID and MaleID which represents the totality of the missing values in MaleID
* Looking at he NA's in Male ID, we see that all the missing data except one entry, comes from the 19th of april 2023 in Noha. We can also see that trials had bee made in the same day, and looking at the time of the experiment, the previous trails made and the audience we can see that these NA's in female and male ID are in the rows 1699 to 1716 and should have been made with **Xian** for the female ID and **Pom** for the **MaleID**. I will thus replace these values using a condtion. These NA's in Noha (Trial 1699 to 1716) are the only NA's that MaleID has and are the only NA's of female ID in Noha. I will thus replace every NA of **MaleID NA in Noha** with **Pom** and every **Female ID NA in Noha** with **Xian**


```{r Male ID NA, echo=FALSE}
library(dplyr)

# Update the dataset
Bex <- Bex %>%
  mutate(
    MaleID = ifelse(Group == "Noha" & is.na(MaleID), "Pom", MaleID),
    FemaleID = ifelse(Group == "Noha" & is.na(FemaleID), "Xian", FemaleID)
  )

```


* In order to clean FemaleID, I will use the data from the now complete MaleID. I will use conditions stating that depending which name is found in MaleID when there is an NA in FemaleID, a certain name will have to replace the NA in female ID:

  If there is NA in female ID, we will eplace the value with 
    - Sirk if MaleID is Sey
    - Ouli if MaleID  is Xin
    - Piep if MaleID  is  Xia 
    - Oerw if MaleID  is  Nge 
    - Oort if MaleID  is  Kom 
    - Ginq if MaleID  is  Sho 
    - Ndaw if MaleID  is  Buk 

```{r FemaleID, include=FALSE}

library(dplyr)

# Assuming Bex is your data frame
Bex <- Bex %>%
  mutate(
    FemaleID = case_when(
      is.na(FemaleID) & MaleID == "Sey" ~ "Sirk",
      is.na(FemaleID) & MaleID == "Xin" ~ "Ouli",
      is.na(FemaleID) & MaleID == "Xia" ~ "Piep",
      is.na(FemaleID) & MaleID == "Nge" ~ "Oerw",
      is.na(FemaleID) & MaleID == "Kom" ~ "Oort",
      is.na(FemaleID) & MaleID == "Sho" ~ "Ginq",
      is.na(FemaleID) & MaleID == "Buk" ~ "Ndaw",
      TRUE ~ FemaleID  # Keep the existing value if none of the conditions are met
    )
  )


# Count NA values in MaleID
na_count_male <- sum(is.na(Bex$MaleID))
cat("Number of NA values in MaleID: ", na_count_male, "\n")

# Count NA values in FemaleID
na_count_female <- sum(is.na(Bex$FemaleID))
cat("Number of NA values in FemaleID: ", na_count_female, "\n")

```


* After the use of the conditions in FemaleID I could see the the changes where successufly done and that 0 NA's are remaing in both FemaleID and MaleID



*I HAVE TO CHECK IF THE ROW IS STILL HERE AND WHAT TO DO ABOUT IT The row 1915 explains to us that the experiment was not possible because we had a BGE and could not do the experiment. I would like to count this line by putting a 1 in No trial but I don't want to keep this line in Male or Female ID. I will have to see how I treat this line since no trial was made, meaning I cannot put any value in DyadDistance, ID (Male and Female) nor DyadResponse


* Row numbers of Female and Male ID to check if every line was correctly changed
* Female ID: 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1886 1887 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 

* Male ID: 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 
Number of missing values in MaleID:  18 




#### 2.11 Cleaning FemaleCorn

```{r FemaleCorn, echo=FALSE}
# Replace NA values in "FemaleCorn" with 0
Bex$FemaleCorn <- ifelse(is.na(Bex$FemaleCorn), 0, Bex$FemaleCorn)

# Check how many NA values are left in "FemaleCorn"
remaining_na <- sum(is.na(Bex$FemaleCorn))
cat("Number of remaining NA values in FemaleCorn:", remaining_na, "\n")
```



#### 2.12 Final check: remaing NA's in Bex?

```{r Check if Remaing NA, echo=FALSE}
# Find columns with NA values
columns_with_na <- colnames(Bex)[colSums(is.na(Bex)) > 0]

# Print the columns with NA values
cat("Columns with NA values:", toString(columns_with_na), "\n")

# Print the number of NA values in each column
for (col in columns_with_na) {
  cat("Number of NA values in", col, ":", sum(is.na(Bex[[col]])), "\n")
}


```
    
    
  * The remaining rows with NA's are the row **866** that I will delete since no information at all is available for the DyadResponse. Concerning the row **1211** we can see that the corn was stolen by Oup and Oort. This means that tolerance way achieved and that an agonistic behaviour followed that is maybe not aggression. I will change the DyadResponse of this row to "Other"
  
```{r Cleaning remaining, include=FALSE}
# Delete row where no information is available for DyadResponse
Bex <- Bex[!is.na(Bex$DyadResponse), ]

# Change DyadResponse where the corn was stolen to "Other"
Bex$DyadResponse[Bex$DyadResponse == "Unknown" & Bex$FoodSource == "Stolen corn by Oup & Oort"] <- "Other"

# Find rows with any NA values in the dataset
rows_with_na_numbers <- which(rowSums(is.na(Bex)) > 0)

# Print the number of rows with NA values and their row numbers
cat("Number of rows with NA values in the dataset:", length(rows_with_na_numbers), "\n")
cat("Row numbers with NA values:", toString(rows_with_na_numbers), "\n")

```

* It seems now that no NA's are remaining in the dataset, we can thus continue with the process of cleaning the dataset

### 3. Creating New Variables and modifying the existing ones

#### Making a backup of Bex
* I will now continue making changes, in case they are any problems or comparason to be made I may use this function to look how Bex looked at that point

```{r Backup Bex 1, include=FALSE}
# Create a backup
backup_Bex <- Bex
```


* I will now treat the remaining variables, let's see which ones and why

```{r Bex Names, include=FALSE}


# Get the names of variables in the dataframe
variable_names <- names(Bex)

# Print the list of variable names
cat("Variable names: ", toString(variable_names), "\n")
print(variable_names)


```

#### Time - Creation of Period nad Hour
* Time : I did not plan to use this variable but since I used, I considered looking at the time sections in which we did the expermiment. I will thus look at the time ranges (max and min in the day / latest and earliest time) before separating the day in different sections to have an idea in which part of the day most of the experiments occured. This will not be used in my analysis, but if I wanted to, I could interesting to compare the amount of experimentations made per day and have a line indicating the time of sunrise. 

```{r Time Periods, include=FALSE}
Bex <- Bex %>%
  mutate(Time = as.POSIXct(Time, format = "%H:%M:%S"),
         Period = case_when(
           between(hour(Time), 6, 8) ~ "Early Morning",
           between(hour(Time), 8, 10) ~ "Morning",
           between(hour(Time), 10, 12) ~ "Noon",
           between(hour(Time), 12, 14) ~ "Afternoon",
           between(hour(Time), 14, 17) ~ "End of the Day",
           TRUE ~ NA_character_
         )
  )

```
* The **Minimum Time** in the dataset is **06:03:26*** while the **Maximum Time** is at **16:36:59**
* In my box experiment I have this variable called time that tells me when the experiment was done. I don't think I need this information per se. I was wondering if it could be easy and interesting to see from when to when the time occurs and then separate this time in a few sections like early, monring, morning, miday, afternoon, end of the day
* a.6 to 8 : Early morning
  b.8 to 10: Morning
  c.10 to 12: Noon
  d.12 to 14: Afternoon
  e.14 to 17: End of the day
  
* Last, I want to create a variable called Hour that will take the value in Time and  round it to the hour in which it is ex: from 06:00 to 06:59 -> 6, from 07:00 to 07:59 -> 7 etc...
* This will allow me to see when most of the trials occured with more detail and I will be to see in which hour most of the trial happened. Nevertheless Period will be better for an improved readability
```{r Hour, include=FALSE}

Bex <- Bex %>%
  mutate(Time = as.POSIXct(Time, format = "%H:%M:%S"),  # Convert Time back to POSIXct
         Hour = floor_date(Time, "hour"),  # Create Hour variable
         Hour = format(Hour, "%H:%M:%S"),  # Format Hour for display
         Time = format(Time, "%H:%M:%S"))  # Format Time for display


```

#### Date - Creation of Month and Day
*  i want to Create a variable called month to see the month of the experiment and day so I know which day of the experiment it was (1st, 10th, 1000th..)
```{r Month and Day, include=FALSE}

# Assuming 'Date' is the name of your variable
Bex <- Bex %>%
  arrange(Date) %>%  # Arrange data in ascending order of Date
  mutate(
    Day = as.numeric(difftime(Date, min(Date), units = "days")) + 1,  # Assign a unique day number
    Month = format(Date, "%Y-%m")  # Include both year and month in Month variable
  )

```


#### Group - Ok
#### Male and Female ID - Creation of Dyad, Trial and Session

* I will use Female and Male ID to create different variables
  1. While checking if there are still any mistakes  in **FemaleID and MaleID** using **unique**, I saw that some of the names are in the wrong rows. I want the **3 letter male codes** whether they are in the column FemaleID or MaleID to be in the **new column Male** while I want the **4 letter female codes** whether they are in FemaleID or MaleID to be in the **new column Female** before checking again with unique that the transformation worked. I will use mutate
```{r Female Male ID Check, echo=FALSE}
#Unique outputs for FemaleID
unique_female_ids <- unique(Bex$FemaleID)
cat("Unique Female IDs:", unique_female_ids, "\n")

# Count the occurrences of each name before the transformation
table(Bex$FemaleID)

# Unique outputs for MaleID
unique_male_ids <- unique(Bex$MaleID)
cat("Unique Male IDs:", unique_male_ids, "\n")

# Count the occurrences of each name before the transformation
table(Bex$MaleID)


before_summary <- table(Bex$FemaleID, Bex$MaleID)
kable(print(before_summary))

```
1. Create a variable called Male that in each row will take the name of the **3 letter code** that is either in MaleID or Female ID and a variable called Female that in each row will take the name of the **4 letter code** that is either in MaleID or FemaleID

```{r Female Male ID correction, echo=FALSE}

# Check and remove existing columns
if ("Male" %in% names(Bex)) {
  Bex$Male <- NULL  # Remove the existing Male column
}

if ("Female" %in% names(Bex)) {
  Bex$Female <- NULL  # Remove the existing Female column
}

# Create Male and Female variables
Bex <- Bex %>%
  mutate(
    Male = ifelse(nchar(MaleID) == 3, as.character(MaleID), ifelse(nchar(FemaleID) == 3, FemaleID, NA)),
    Female = ifelse(nchar(FemaleID) == 4, FemaleID, ifelse(nchar(MaleID) == 4, MaleID, NA))
  )

# Create Dyad variable
Bex <- Bex %>%
  mutate(Dyad = paste(Male, Female, sep = " "))


# Check and summarize unique Female and Male IDs after the transformation
unique_female <- unique(Bex$Female)
unique_male <- unique(Bex$Male)
unique_dyad <- unique(Bex$Dyad)

cat("\nUnique Female:", unique_female, "\n")
cat("Unique Male:", unique_male, "\n")
cat("Unique Dyad", unique_dyad, "\n")

kable(table(Bex$Dyad))


```
  
  # Correct from here, mistake were inserted in dyad by changin wrong lines 




  2. Create the variable called **Dyad** created by combining the name of FemaleID and MaleID into one name with a space between the two codes. For information the 3 letter code is the name of the female     while the 4 letter code is the name of the male like displayed here;

    Var1	Freq
Buk Ginq	1
Buk Ndaw	257
Kom Oort	366
Nge Oerw	181
Pom Guat	5
Pom Xian	257
Sey Sirk	584
Sho Ginq	278
Xia Piep	606
Xin Oort	4
Xin Ouli	185


  * They are a few **wrong dyads** that I will have to identify in the dataset and manuallly correct, those wrong dyads to change and identify are:
    -Buk Ginq - 6 occurences
    -Xin Oort - 4 occurences
  
```{r Identify Wrong Dyads, echo=FALSE}

# Part 1: Identify rows with wrong dyads
wrong_dyads <- c("Buk Ginq", "Xin Oort")

# Identify the rows with wrong dyads
wrong_rows <- which(Bex$Dyad %in% wrong_dyads)

# Part 3: Print wron rows and dyads
print(wrong_rows)
print(wrong_dyads)



```
* 

  * I will change the occurences of **Buk Ginq** to **Sho Ginq** for **row 605 to 609** and **row 921**. I know these triasl are with SHo Ginq because the comments metionned Sho in them while Male(ID) gave Buk
  * For the **rows from 2692 to 2695** since, Ouli is in the audience it is unlikely that we had trials with the dyad **Xin Ouli**. Also I think they are little chances that the names of both individuals     were entered wrong. I will replace these occurences where we had **Xin Oort** by **Kom Oort**
  
  * I thus want **Buk** to be replaced in male ID in rows 605 to 609 and row 921 with **Sho** and, **Xin** to be replaced by **Kom** in rows 2692 to 2695 in Male ID before updating Dyad
  
  
```{r Correct Wrong Dyads, echo=FALSE}

# Check if corrections have already been made for "Sho"
if (!all(Bex$MaleID[605:609] == "Sho")) {
  # Correct "Buk" with "Sho" in row 921
  Bex$MaleID[605:609] <- "Sho"
}

# Check if corrections have already been made for "Sho"
if (!all(Bex$MaleID[921] == "Sho")) {
  # Correct "Buk" with "Sho" in row 921
  Bex$MaleID[921] <- "Sho"
}



# Check if corrections have already been made for "Kom"
if (!all(Bex$MaleID[2692:2695] == "Kom")) {
  # Correct "Xin" with "Kom" in rows 2536 to 2539
  Bex$MaleID[2692:2695] <- "Kom"
}


# Delete duplicate rows if any
Bex <- Bex[!duplicated(Bex), ]

# Update Dyad based on the corrected MaleID
Bex <- Bex %>%
  mutate(
    Dyad = paste(
      ifelse(nchar(MaleID) == 3, MaleID, ifelse(nchar(FemaleID) == 3, FemaleID, NA)),
      " ",
      ifelse(nchar(FemaleID) == 4, FemaleID, ifelse(nchar(MaleID) == 4, MaleID, NA))
    )
  )

# Check and summarize unique MaleIDs and Dyads after correction
unique_male <- unique(Bex$MaleID)
cat("Unique Male after correction", unique_male, "\n")

unique_dyad <- unique(Bex$Dyad)
cat("Unique Dyad after correction", unique_dyad, "\n")

kable(table(Bex$MaleID))
kable(table(Bex$Dyad))




```

  

  3. Create the variable called **Trial** where the data will be **sorted by date and dyad** in order to see how many trials have been done with each individual: **One row (per dyad) = one trial** and the    variable called **Day** where the data will be **sorted by date and dyad and day** in order to see how many sessions have been done with each individual: **One day (per dyad) = one session**
  Now, let's proceed with creating the Dyad variable, Trial, and Day:
  
  

```{r Dyad and Day, include=FALSE}
# Create Trial variable
Bex <- Bex %>%
  arrange(Date, Dyad) %>%
  group_by(Dyad) %>%
  mutate(Trial = row_number())

# Create Day variable  # (Changed 'Session' to 'Day' for better clarity)
Bex <- Bex %>%
  arrange(Dyad, Date) %>%
  group_by(Dyad, Date) %>%
  mutate(Day = cur_group_id())

```
4. Make a summary of trial and session so I can see see how many trials and sessions have been done with the individuals
```{r Dyad and Day Summary, echo=FALSE}
# Summary of Trial and Day
summary_trial <- Bex %>%
  group_by(Dyad) %>%
  summarise(Num_Trials = max(Trial))

summary_Day <- Bex %>%
  group_by(Dyad) %>%
  summarise(Num_y = max(Day))

cat("Trial Summary:\n")
print(summary_trial)

cat("\nDay Summary:\n")
print(summary_Day)

kable(table(Bex$Dyad))

```




  

#### Female Corn and Male Corn 

* The idea is that for each Dyad, we gave an amount of corn to attract the monkey of a dyad to the right distance of his partner for a trial by putting corn in experiment box that he could get by approaching. We repeated this step as much as needed to have our Dyad at the desired distance to continue the trials from the previous day of experimentation. This means I will only Keep the last number per dyad and day for each day. 
* I decided to create **two variables**, that are called **PlacementMale** and **PlacementFemale** that will only keep the final amount of corn given to each individual within a day of experiment

```{r FemaleMale Corn, echo=FALSE}



Bex <- Bex %>%
  arrange(Dyad, Date) %>%
  group_by(Dyad, Day) %>%
  mutate(
    PlacementMale = last(MaleCorn),
    PlacementFemale = last(FemaleCorn)
  )

```

#### DyadDistance - Creation of proximity
* I would like to create a variable called proximity to have another measure of the proximity of the individuals. 
* First lets look at the maximum and minimum distance found in Dyad Distance
```{r DyadDistance Max & Min, echo=FALSE}
# Find maximum distance
max_distance <- max(Bex$DyadDistance, na.rm = TRUE)

# Find minimum distance
min_distance <- min(Bex$DyadDistance, na.rm = TRUE)

# Print the results
cat("Maximum Distance:", max_distance, "\n")
cat("Minimum Distance:", min_distance, "\n")

```
* The **minumum Distance** is **0m** while the **maximum Distance** is **10m**
* Now lets create a new variable called **Proximity** using the distances found in **DyadDistance** on the following model:
  a. 0 = Contact
  b. 1 - 2 = Very close
  c. 2 - 3 = Close
  d. 4 - 5 = Distant
  e. 5 - 6 = Far
  d. 7 - 8 = Very Far
  f. 9 - 10 = Maximum Distance
  
```{r Proximity, echo=FALSE}
  # Assuming 'DyadDistance' is the name of your distance variable
Bex <- Bex %>%
  mutate(
    Proximity = case_when(
      DyadDistance == 0 ~ "Contact",
      between(DyadDistance, 1, 2) ~ "Very Close",
      between(DyadDistance, 2, 3) ~ "Close",
      between(DyadDistance, 4, 5) ~ "Distant",
      between(DyadDistance, 5, 6) ~ "Far",
      between(DyadDistance, 7, 8) ~ "Very Far",
      between(DyadDistance, 9, 10) ~ "Maximum Distance",
      TRUE ~ NA_character_
    )
  )

# Print the first few rows of the updated dataset
View(Bex)

  
```

* Dyad Response - Detailed cleaning
* Other Reponse - DEtailed cleaning to delete the column
* Audience - Creation of Amount Audience and Density
* ID Individua1 - Not sure yet
* Intruder ID 
* Remarks - Detailed Cleaning
* Intrusion
* Not Approaching
* Lossing Interest
* Distracted
* MultipleResponse
* Amount Audience
* DyadDistance
* Distance
* No trial

```{r temporary section}
head(Bex$Time)

```




   * I want to use the date to know **how many sessions** have been done with each dyads in my experiment. 
    * I will create a variable called **Session** where **1 session = 1 day**
    * The data has values from the **14th of September 2022** until the **13th of September 2023**
    * I will also create a variable called **Trial** to know how many trials have been done with each dyad where **1 row = 1 trial** 
    
    * I may consider, in parallel of my hypothesis, to separate the data in *4 seasons* to make a preliminary check of a potential effect of seasonality. Nevertheless the fact that we did not use anywithout      tools to mesure the weather and the idea to make a categorization in 4 seasons without considering the actua quite arbitrary. I may do it but with no intention to include this in my scientific report.
    l temperature, food quantitiy and other elements related to seasonailty make this categorizationn a categorization where 12 months of          data will be separated in 4 categories
   


* But before I may want to make a few changes already by merging **Male corn** and **Male placement corn** into " Male corn" and maybe replacing all of the NA's in "Other response" by response

#Lines to check unique values in MaleFemaleID to see if they are any problems with it
# Unique values in MaleID
unique_male_ids <- unique(Bex$MaleID)

# Unique values in FemaleID
unique_female_ids <- unique(Bex$FemaleID)

# Print the unique values
cat("Unique values in MaleID: ", toString(unique_male_ids), "\n")
cat("Unique values in FemaleID: ", toString(unique_female_ids), "\n")








# Sections below are here for the organization of my paper and will be worked on once the data cleaning and exploration is done

## 3. Describing the data

## 4.Visualizing the data

## 5.Research question & Hypothesis

### Research question

-   What factors influence the rate at which individuals (vervets) learn
    to tolerate each other in a controlled box experiment?

-   Ex: The rate at which individuals (vervets) learn to tolerate each
    other in a box experiment is influenced by social factors (audience,
    social network, behavior of the partner) and idioyncratic factors
    (age, rank)

### Hypothesis

-   1.  Hypothesis about the Presence of High-Ranking Individuals:

The presence of a higher number of high-ranking individuals in the
audience will negatively correlate with the level of tolerance achieved
among vervets in the box experiment. This is expected to result in
higher frequencies of aggressive behaviors, intrusions, and loss of
interest, particularly from lower-ranking individuals.

-   2.  Hypothesis about Partner Agonistic Behaviors:

Vervets tolerance levels in the box experiment will be influenced by
their partner’s display of agonistic behaviors. Specifically, partners
who exhibit more frequent agonistic behaviors towards their partner will
lead to decrease in their motivation to participate in future trials.

-   3.  Hypothesis about the Establishment of an Optimal Distance:

During the box experiment, vervet dyads will establish an “optimal”
distance for interaction, characterized by a higher frequency of
tolerance compared to other distances. This optimal distance is expected
to signify that the individuals tolerate each other more effectively at
this specific proximity .

-   4.  Hypothesis about Age and Rank:

The age and rank of individual vervets within the group will influence
the success of the trials in the box experiment. Specifically, older and
higher-ranking individuals are expected to exhibit lower rates of
success compared to dyads consisting of younger and lower-ranked
individuals. This decrease in success is anticipated to be associated
with a higher frequency of aggressive behaviors displayed by older and
higher-ranking individuals towards their partners. (I’m not sure this
hypothesis makes sens, I have the feeling age and rank must have an
influence but I don’t know how to put it, I will think about it)

-   5.  Hyptohesis about seasonality

Seasonality is expected to impact the motivation of vervet dyads to
participate in the box experiment. We hypothesize that dyads will have
lower motivation, as indicated by a reduced number of trials, during the
summer months compared to the winter months. This difference in
motivation is likely influenced by temperature and food availability. To
test this hypothesis, we will categorize the data into four seasonal
periods, each spanning four months, and analyze whether there is a
significant effect of seasonality on the motivation to engage in the
trials.

## 6.Statistical tests and analisis of the data

### Statistical tests

-   **Hypothesis 1**: Influence of High-Ranking Individuals

Variables Needed:

**DyadResponse** (specifically, “aggression” responses)
**Amountaudience** (to measure the number of individuals in the
audience) **Audience…15** (to identify the names of individuals in the
audience for calculating dominance ranks) **Elo rating** of the
individuals based on the ab libitum data collected in IVP (which I have
to calculate asap)

Statistical Analysis:**Logistic Regression**, as it could analyze the
influence of high-ranking individuals on the occurrence of aggression in
dyad responses. This will help determine whether the presence of
high-ranking individuals affects the likelihood of aggression.

-   **Hypothesis 2**: Impact of Partner’s Agonistic Behaviors

Variables Needed:

-   **DyadResponse** (specifically, “aggression” responses)
-   **MaleagressF** (male’s aggression towards female)
-   **FemaleaggressM** (female’s aggression towards male)

Statistical Analysis: **Logistic Regression** as it could be used to
assess how the occurrence of aggression in dyad responses is influenced
by the partner’s gender-specific agonistic behaviors.

-   **Hypothesis 3**: Identification of an Optimal Interaction Distance

Variables Needed:

-   **DyadDistance** (distance between boxes)
-   **Tolerance** (as a binary outcome)

Statistical Analysis: **generalized Linear Model (GLM)** to investigate
whether there is an optimal distance that leads to a higher likelihood
of tolerance (Tolerance = 1).

-   **Hypothesis 4**: Role of Age and Rank

Variables Needed:

-   **Tolerance** (as a binary outcome)
-   **Male and Female** (to identify individuals’ ages and ranks)
-   **Dyad** (to link individuals to dyads)
-   **Birthdate** to calculate the age of each individual

Statistical Analysis: **Logistic Regression** Logistic regression can be
employed to determine whether the age and rank of individual vervets
within dyads have an impact on the likelihood of tolerance (Tolerance =
1).

-   **Hypothesis 5**: Influence of Seasonality

Variables Needed:

-   **Date** (to categorize data into seasons)
-   **Trial** (to count the number of trials in each season) and the
    data for at least 365 days so i can separate the data in 4 (1 year =
    4 seasons = 12\*4 month) to see if they may be an effect of
    seasonality on the motivation (amount of trials) of the dyads

Statistical Analysis:

ANOVA or Kruskal-Wallis Test: Depending on the distribution of your
trial data, you can use either ANOVA (if the data are normally
distributed) or the Kruskal-Wallis test (for non-normally distributed
data) to assess the impact of seasonality on the number of trials. If
significant differences are found, you can follow up with post-hoc tests
to identify which seasons differ from each other. Please note that the
effectiveness of these analyses may depend on the distribution of your
data and specific research objectives. You may also consider conducting
exploratory data analysis (e.g., visualization) to gain a better
understanding of your dataset before performing these analyses.
Additionally, if you have specific questions about data preprocessing or
variable transformations, feel free to ask for further guidance. –> I
took this from ChatGPT, I have to look more into it

**REMARKS**: So here are a few updates I made in the document. I also
planned to send my cleaned data to Radu (the statistician of UNINE) as
he was keen to help me find the right test. Of course I will also look
again in Bshary’s and Charlotte’s work with the boxes and improve these
suggestions that are quite simple for now

Also I still have to clean the last grpahs about male/female aggression
as I didn’t finish that yet. I juste wanted to share my hypothesis and
ideas for statistics so I can soon go into the “serious” work

Anyway, thank you in advance for your help \<3

Michael

## 7. Plotting the results of the analysis

## 9. Interpretation of the results

## 10. Comeback on the research question and hypothesis

## 11. Bibliography

## 12. Organization for my paper

-   Introduction
    -   Tolerance humans, primates
    -   Apes vs monkeys / Captivity vs Wild
    -   IVP: Wild habituated vervets, experiments possible
    -   Paper Bshary, Canteloup… Prolongation study
    -   Relevance idea/topic research
    -   Research question & hypothesis

But: intro need triangle shape: broad to narrow end wiht research
question> tolerance importance \> animal reign, actual knowledge/
direction knowledge we need \> show how my experiment goes in that way
How to adress the gap, answer with research question

Then explain why choosing vervet monkeys, (IVP in methods), sociality,
experiments made

-   Methods

    -   IVP, research area, (goal, house, type people)

    -   Population: groups, dyads, male/female, ranks..

    -   Box material: boxes, remotes, batteries, camera, tripod, corn
        (no marmelade ;), (water spray, security reason, non agressive
        way to select individuals and not engage with mokeys when
        reachrging boxes with corn), pattern, previous distances,
        tablets, box experiment form

    -   Tablets

    -   (No observers mentionned)

    -   Habituation boxes > individuals trained to recognice boxes, they
        have differernt levels of habituation

    -   Patterns > appendix, mention similar to habituation, use to
        recognize box but efficieny depeds of experience)

    -   Selection dyads > assigment from elo rating (different rank), if
        above average bond no dyad made, if not possible, availibilty of
        monkey also factor !! Non random can be a problem, think about
        why and how you selected data We created variations in dyads
        made by different sex, rank and not above average bonde
        (calculate bondeness)

    -   Amount corn, do you want to mention it> maybe important
        Calculate corn during and placement cf paper on corn /food
        motivation

    -   Corn (daily intake vervet % made from corn, cf site we saw, cf
        screenshot, comapre paper previousely made an all)

    -   1st dyad trial (BD) > appendix

    -   Videos > details appendix

    -   Finding dyads > appendix

    -   Placement to attract them > meniton if statiscial made on
        placement corn

    -   Trials (1 session = max 15 trials/in total) (session could be
        broken in different sub sessions to reach 15 trials max)

    -   If agression > 1m / If 2x tolerance \< 1m , also if not
        approaching > 1m ( if no tolerance increase distance except if
        intrusion) (borgeaud > expectation fo aggression)

    -   Time of the day > appendix

    -   Territory? > appendix

    -   Amount sessions p day/week, how we chose the moment to follow
        them >appendix

    -   Problems/ unplanned events: weather, BGE’s, not finding the
        monkeys (group, dyad or individual), dispersal of males, river
        crossing, inacessibility (experiments or boxes), low vision
        (experiments or monkeys),> appendix

    -   (Where do i mention the confounding variables?) > look in
        litterature, if something that could affect and already reported
        in papers check, oterhwise exclude “normal life” factors for
        both monekys and Experimenter

    -   Types of experimental plan

    -   Statistical tests (for each hypothesis)

-   Analysis

-   Results

-   Interpretation

-   Conclusion


#########

# Glossary
* **Tolerance**: Tolerance: An individual has an encounter with a conspecific and
  can freely leave but remains in the encounter without acting aggressively
  toward the conspecific. (Pisor & Surbeck, 2019)
* **Agression**
* **Session** 
* **Trial**
* **Group**: In the Primate order, groups are individuals “which remain [physically] together in or separate from a larger unit” and interact with each other more than with other individuals.6 This            definition does not cover all uses of the word “group” in the social sciences (e.g., human identity groups who identify with a common name or symbol may or may not interact with one another more frequently   than with other individuals). Because of this ambiguity, we use the word “community” when referring to humans to better capture the notion of spatial proximity, per Ref. 54. Members of the same group are    referred to as “same-group” and those from another group “extra-group.” (Pisor & Surbeck, 2019)


# Bibliography
 • Pisor, A. C., & Surbeck, M. (2019). The evolution of intergroup tolerance in nonhuman primates and humans. Evolutionary Anthropology: Issues and Reviews. Advance online publication. https://doi.org/10.1002/evan.21793
(Pisor & Surbeck, 2019)


# Annex

#### Annex 1 : View of the dataset when imported - First 6 entries of each variable 
* We can see here the brief view of the **original dataset** names **BoxEx**when i initially imported it as seen in **section 0: Opening data** 



```{r View of the data Boxex, echo=FALSE}

# Display the original dataset that is name Boxex
pander(head(Boxex), style = "rmarkdown", caption = "First Few Entries") 

```
