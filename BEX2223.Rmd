---
title: "Testing for Tolerance in a Box Experiment in Wild Vervet Monkeys - M.AungKyaw - 2022-2023" 
output:
  html_document:
    df_print: paged
---



```{r setup, include=FALSE}
# Set global knitr options
knitr::opts_chunk$set(echo = TRUE)
```

<center>
    <img src="/Users/maki/Desktop/Master Thesis/BEX 2223 Master Thesis Maung Kyaw/BEX Visuals/Minimalist-vervet-box-logo.png" alt="Minimalist Vervet Box Logo" style="width: 50%; height: auto;"/>
</center>



## Introduction


## 0.Opening the data
### Loading data

```{r LoadData, include=FALSE}

# Load knitr for  markdown outputs
library(knitr)

##Load pander for better presentation of the outputs
library(pander)

##Load dplyr for better manipulation of the data
library(dplyr)

# Load readxl package to import the data
library("readxl")

# Load Lubridate for better date and time manipulation
library(lubridate)

# Load Stringr for easier data manipulation and cleaning
library(stringr)

# Read xlsx files
Boxex <- read_xls("/Users/maki/Desktop/Master Thesis/BEX 2223 Master Thesis MAung Kyaw/Makipurple3/Box Experiments.xls")

``` 

* First I downloaded the **knitr package** to create outputs as html, pdf or word files when knitting my r markdown file. I also loaded the **pander** package for better presentation
* The **dplyr** package was installed for better manipulation of the data as filtering or creating new variables and **lubridate** for a better manipulation of dates and time
* Then, I installed the **readxl package** to import my dataset which is called **Box Experiments.xls**
* This dataset contains information related to my master thesis project. I used cyber tracker in order to record the behaviors of dyads of Vervet monkeys in a box experiment on tolerance from September 2022 to September 2023

## 1.Explore the data

### Description of the initial datset - "Boxex"

```{r View and Glimpse of Boxex, echo=FALSE}

# First view of my datset
View(Boxex)

#GLimpse function to see the summary and  the structure

cat("Glimpse of the the Box Experiment dataset:\n\n")
glimpse(Boxex)
```



* I am now using the **view** function to have a sight on the entire dataset and **glimpse** to display a summary of my dataset
* I have **20 variables** (here columns) and **2795 trials** (here rows)

* I will now make a brief summary of each variables and their use before creating a new dataframe (df) with my variables of interest that I will call **Bex**

* The highlighted variables are the ones I will use for **Bex**. I will then **clean the data**  before heading to the **statistical analysis** and the **interpretation of the results**


#### Variables of Boxex

* **Date**               :
    "Date" is in a **POSIXct** format which is appropriate for the display of time 

    * I want to use the date to know **how many sessions** have been done with each dyads in my experiment. 
    * I will create a variable called **Session** where **1 session = 1 day**
    * The data has values from the **14th of September 2022** until the **13th of September 2023**
    * I may consider separating the **12 months** of data in **4 seasons** to make a preliminary check of a potential effect of seasonality. Nevertheless since we did not use any tools to measure the weather,         temperature, humidity or food availability (also related to seasonality and weather). Categorizing my data in 4 without having further data would then be quite arbitrary. If I end up doing it in my          report, it will be done without any intention to include it in my scientific analysis nor my scientific report .
    

    
* **Time**                  : 
     "Time is coded" in a **POSIXct** format 
     
    * I do not plan to use this variable but we can see that "Time" has the correct hours displayed with a date which is incorrect. 
    * (In the case I wanted to observe **when the trials occurred during the day** as time may have an influence on their behavior (**Isbell & Young 1993**)) I would need to correct the incorrect display of the date in the dataset.
    * This variable could also be useful to see when  the **seasonal effect** took place as we only went in the morning during summer because of the heat while we went later and for longer times in the          field to do the box experiment in winter 
    * For now, the values in "Time" are all on the same (wrong) day which is the **31st  of December** 
    * Note: I first did not intend to keep **Time** in Bex but I needed this variable to see the order of the trails within a day. I finally decided to keep it.
    
* Data                   : chr 
    "Data" is coded as **character**
    * It describes **the type of data** being recorded in the software **cybertracker**. We installed the software on tablets to record the different behaviors of vervet monkeys in our research center
    * In our case, my data was recorded in cybertracker as **Box Experiment** as we created a form specifically for this experiment
    * For this reason we can remove this column since the information it contains is unecessary and redundant
      
* Group             : chr 
    The data is coded in r as a **character**
    * It describes the **group of monkey** in which we did the trial
    * I will keep this column to see the amount of trials that we did in the 3 group of monkeys which are Baie-Dankie **(BD)**, Ankhase **(AK)**, and Noha **(NH)**
      
* GPSS                   : num 
    "GPSS" is coded as **numerical**
    * It gives the **south coordinates** in which we started the experiment
    * I do not plan to use coordinates nor look at locations so I will remove this acolumn
    
* GPSE                   : num 
    "GPSE" is coded in as **numerical**
    * It gives the **east coordinates** in which we started the experiment
    * I do not plan to use coordinates nor look at locations so I will remove this column
  
* **MaleID**             : chr 
    "MaleID" is coded as **character**
    * It indicates the **name of the male involved in the trial**
    * I plan to use this to see how factors related to the individual may influence the            experiment (age, sex, rank)
    * It will also help me see which behaviour was displayed by each individuals (here males)
  
  
* **FemaleID**           : chr
    "FemaleID" is coded as **character**
    * It indicates the **name of the female involved in the trial**
    * I plan to use this variable in the same way as "Male ID"
    * It will also help me see which behaviour was displayed by each individuals (here females)
    
* **Male placement corn**: dbl
    "Male placement corn is coded in r as **double**
    * It gives the **amount of corn given to the male of the dyad before the trials**
    * Within a session it happened that we gave more placement corn to attract the monkeys again to the boxes. This lead to an update of the number in the same session. The number found at the end of the         session is the total placement corn an individual has received
    * I will fuse this column with **male corn** as the data has been separated between these two variables. This is due to a mistake when creating the original box experiment form in cybertracker
    
    * This variable could be related to the level of motivation of a monkey but as it is not directly related to my hypothesis I may not use this column. I will re-consider the use of this column later on
    * In regards of this possibility I will change the format of the variable to numerical 
  
* **MaleCorn**           : dbl
    "MaleCorn" is coded in r as **double**
    * It gives the same information as in **male placement corn**
    * I will import the values from "male placement corn" into this one
    * I will change the format of the variable to numerical 
    
    
* **FemaleCorn**         : dbl
    The data is coded in r as **double**
    * It gives the **amount of corn given to the female of the dyad before the trials**
    * It works in the same way as "male placement corn"/"MaleCORN"
    * I will change the format of the variable to numerical 
  
  
* **DyadDistance**       : chr 
    The data is coded in r as **character**
    * It gives the **distance for each trial** that we have done with the dyads. 
    * The trial number 1 for each dyad was at 5 meters. 
    * The maximum was around 10 m while the minimum is 0
    * We will have to remove the "m" for meters in order to have a numerical variable instead of character
    * Also, since the very first trials per dyad can be considered as a kind of learning phase, i may remove the **15 first trials** that were made for each dyad
  
* **DyadResponse**       : chr 
    The data is coded in r as **character**
    * It indicated which **behaviour was produced by the dyad's during each trial**
    * The different behaviours were: **Distracted**, **Female aggress male**, **Male aggress female**, **Intrusion**, **Loosing interest**, **Not approaching**, **Tolerance** and **Other**
    * I will change the columns associated to each behavior (i.e. Response) of  **DyadResponse**    into dichotomic variables in order to see the frequency of each behaviour
    * This will allow me to see which behavior occurred more ,and behavioural differences could be found between dyads 
    * As multiple response could occur within the same trial, multiple behaviors can be found in a single cell. I will create a  hierarchy to reduce the amount of behaviors assigned to each trial (if  there     is more than one). This will also be complemented with the information found in the column **remarks**
      1. correct any mistakes (ex. if tolerance and aggression are together aggression>tolerance)
      2. assign as few labels per trial 
      3. get a better view and understanding of the data and the most common behaviours produced by each dyad
      4. create variables that can complement the behaviour found (ex. not approaching + looks at partner would be looks at partner + a new variable called hesistant to see when the did not come but look at         the other individual / )
      
    * Projection of the hierarchy (changes will be made)
      - Create a table with each combination existing
      
      - Decide what is more important
      - Ex:
        - Aggression > Tolerance
        - Tolerance > Not approaching -> Create a variable called hesistant in         addtion to the tolerance count to see frequency of tolerance                 behaviour that happened after > 1min
        - Tolerance > Loosing interest
        - Tolerance > Intrusion
        - Not approaching = looking box but not coming while Loosing interest           = not paying attention to the box
        - Intrusion > Loosing interest
        - Intrusion > Not approaching
        - Not approaching > Looks at partner
        - We can code every look at partner as no approaching and keep the             count of looks at partner as additional information
        - Not approaching >?> Loosing interest ? !!
        - Define distracted
        - Not approaching > Distracted
        - Aggression > Not approaching
        - Other > Look case by case and categorize depending of behavior
        - Remarks may be used for the same reason
        
  
* **OtherResponse**      : chr 
    "The data"OtherResponse" is coded as **character**
    * It describes **any behaviour that is different from the ones found in Dyad Response**     (meaning ≠ tolerance, aggression, intrusion, loosing interest, not approaching, distracted, looks at partner that where categorized as **other**)
    * I will have to look at every **OtherResponse** and rename each entry in one of the response already if existing. I will proceed case by case.
    * If I want to do an intermediate manipulation I may rename every NA in "OtherResponse" into **Response** to see the amount of case to treat and how many occurrences seem to not fit in the categories of  "DyadResponse"
    
* **Audience**      : chr 
    "Audience" is in r as **character**
    * It gives the **names of the individuals in the audience**
    * I would like to use it to see the **amount of audience (big vs small)** and the **dominance level of the audience (high vs low)** 
    * I will create a variable called **NAudience** to see hoy many individuals are in the audience for each trial
    * After calculating the elo ratings of the individuals using another dataset (Life history), I will create a dichotomic variable called **RankAudience** to see effects related to rank with the effect of audience
    
* **IDIndividual1**      : chr 
    "IDIndividual1" is coded in r as **character**
    * It gives the **names of the individuals that did not approach, showed aggression, got distracted or lost interest** during a trial
    * I will have to look at it to see how often these behaviors occurred
    * I will consider how to use this variable during the cleaning of the data
    
* **IntruderID**         : chr 
    "IndtruderID" is coded as **character**
    * It gives the **name of the individual that intruded the experiment during a trial**
    * Intrusion could mean, invade the space of the experiment and interact with one of our individual, steal the food, show agnostic behavior, stand in very close proximity of the dyad's individuals
    
* **Remarks**            : chr 
    The data is coded in r as **character**
    * It gives either additional information concerning the experiment when unusual behaviors occurred , mistakes that needed to be corrected or details that we wanted to record in        case we would need them
    
* Observers               :chr
    The data is coded in r as **character**
    * It gives the **names of the observers during the experiment**
    * We will not use this data as we do not look at the effect that an experimenter would have on the monkeys
    * (Should I still look at an effect of the amount of experimenter?...maybe better for detailled analysis of our study)
    
* DeviceID             :chr
    "The data "DeviceID" is coded in r as **character**
    * It gives the **name of the device/tablet** used to record the data during the experiment
    * We will not use this data either
    
    

## 2. Cleaning the data

### 2.1. Creating a new dataframe - Bex
* Since I do not want to work with the whole dataset, I'm gonna select the variables of interest using the function **select**

* I will keep Time, Date, Group, MaleID, FemaleID, MaleCorn, Male placement corn, FemaleCorn, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks

```{r Bex Df, echo=FALSE} 
Bex<-Boxex%>%
  select(Time,Date,Group, MaleID, FemaleID, MaleCorn,`Male placement corn`, FemaleCorn, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks )
glimpse(Bex)

View(Bex)
```

#### 2.1.1 Merging Male placement corn and MaleCorn
* I want to process all the missing data in Bex. But before, I will merge the column **MaleCorn** and **Male placement corn** as the data of both columns is supposed to be together under "MaleCorn"
* Looking manually in the Bex table it seems that very few data is in **MaleCorn** while most of it seems to be in **Male placement corn**
* Every time there is a missing value in Male placement corn we can see a value in Male Corn, I will then create a new variable MaleCorn where every time that there is NA in male placement corn the value will be taken in MaleCornOld (previous malecorn). If there is no NA it will take the value of ´Male placement corn´
* I will first **rename MaleCorn to MaleCornOld**, then **check the amount of NA's** and then **merge "MaleCornOld" and "male placement corn"** into the **new variable "MaleCorn"**

```{r handling MaleCorn to MaleCornOld, include=FALSE}

# Check if the dataset has the necessary columns before proceeding 
if ("MaleCorn" %in% colnames(Bex) && "Male placement corn" %in% colnames(Bex)) {

  # Rename MaleCorn to MaleCornOld
  names(Bex)[names(Bex) == "MaleCorn"] <- "MaleCornOld"

  # Check the structure of Bex to confirm the changes
  str(Bex)

  # Check for missing values in MaleCornOld
  NA_MaleCornOld <- Bex[is.na(Bex$MaleCornOld) | is.na(Bex$`Male placement corn`), ]
  print(NA_MaleCornOld)

  # Check the intersection of rows with NA in MaleCornOld and Male placement corn
  Cross_NA <- Bex[is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`), ]
  head(Cross_NA)

  # Count the number of rows where both MaleCornOld and 'Male placement corn' have NA values
  common_na_count <- sum(is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`) & !is.na(Bex$MaleCornOld) & !is.na(Bex$`Male placement corn`))
  # Print the result
  cat("Number of rows with common NAs in MaleCornOld and 'Male placement corn':", common_na_count, "\n")

  # Check the amount of common NA between MaleCornOld and Male placement corn
  common_nas <- sum(is.na(Bex$MaleCornOld) & is.na(Bex$`Male placement corn`))
  print(common_nas)

  # Create a new variable MaleCorn
  Bex$MaleCorn <- ifelse(!is.na(Bex$MaleCornOld) | !is.na(Bex$`Male placement corn`), coalesce(Bex$MaleCornOld, Bex$`Male placement corn`), 0)
  
   # Count occurrences of 0 in MaleCorn
  zero_count <- sum(Bex$MaleCorn == 0)
  cat("Number of occurrences of 0 in MaleCorn:", zero_count, "\n")

  # Check the structure of Bex to confirm the changes
  str(Bex)

  # Remove the original MaleCornOld and Male placement corn
  Bex$MaleCornOld <- Bex$`Male placement corn` <- NULL

  # Check for missing values in the new MaleCorn
  NA_MaleCorn <- Bex[is.na(Bex$MaleCorn), ]
  print(NA_MaleCorn)

} else {
  # Display a message or take alternative actions if columns are missing
  cat("Error: Required columns not found in the dataset.\n")
}



```

* I have found **1499 NA in common** between MaleCornOld and 'male placement corn', **1609 NA in Male placement corn** and **2685 in MaleCorn old**


* For the **merge of MaleCornOld and Male placement corn**, I used different conditions:
1.In this code, a new variable MaleCorn is created. If there is a missing value in Male placement corn, it takes the corresponding value from MaleCornOld; otherwise, it takes the value from Male placementcorn.
2.If there are no value in both MaleCornOld and Male placement corn (NA,NA) for a given row, I would like the code to display 0 as it means that no placement was given
* In this way, I should not loose any data, minimize the mistakes and already transform the NA's of this variable into a number which will remove the remaining NA's which are meant to be 0
* After the merge I found that there were **no NA's remaining** in the **"New" Male Corn** and that **1499 0's** where found in the column which **corresponds to the amount of common NA's found previously** between the **"Old" Male Corn** and **male placement corn**


#### 2.1.2 Cleaning FemaleCorn

```{r FemaleCorn, echo=FALSE}
# Replace NA values in "FemaleCorn" with 0
Bex$FemaleCorn <- ifelse(is.na(Bex$FemaleCorn), 0, Bex$FemaleCorn)

# Check how many NA values are left in "FemaleCorn"
remaining_na <- sum(is.na(Bex$FemaleCorn))
cat("Number of remaining NA values in FemaleCorn:", remaining_na, "\n")
```

### 2.2 Identifying variables with missing data

* Now in order to see where are located the missing points in the data, I'm going to **print** the variables **with and without NA's**

* The function **sapply** is used to apply the function **sum** for NA's to each column of the data frame, so each variable

```{r Find Missing data, echo=FALSE}
# Check for missing data
missing_data <- sapply(Bex, function(x) sum(is.na(x)))

# Print missing data
cat("Variables with Missing Data:\n")
kable(missing_data[missing_data > 0])

cat("Variables with No Missing Data:\n")
kable(missing_data[missing_data == 0])
  
```

* We can see that out of the 14 variables we have in **Bex** we have **9 variables with missing data** which are **Male ID, Female ID, DyadDistance, DyadResponse, OtherResponse, Audience, IDIndividual1, IntruderID, Remarks**:  I will proceed to clean these variables one by one 

* MaleID	19
* FemaleID	60
* DyadDistance	33
* DyadResponse	47
* OtherResponse	2758
* Audience	924
* ID Individual1 2143
* IntruderID 2737
* Remarks 2181

### 2.3 Treating variables with missing data

#### 2.3.1 Cleaning "Remarks" - (2181 NA's)
* Since most of the time we did not have any remarks it is understandable that this variable contains 2181 NA's out of 2795 rows
* I will first transform every missing data in the column Remark into **No Remarks** and then check that the amount of "No remarks" found 

* After the changes we can effectively see that we have **2181 "No Remarks"** and we have no missing data left

```{r Remarks NA, echo=FALSE}

if (!"NoRemarks" %in% names(Bex)) {
  # Replace NA's with "No Remarks" in the "Remarks" column
  Bex$Remarks[is.na(Bex$Remarks)] <- "No Remarks"

 # Check how many times "No Remarks" appears in the "Remarks" column
  no_remarks_count <- sum(Bex$Remarks == "No Remarks")
  cat("Number of 'No Remarks' in the 'Remarks' column:", no_remarks_count, "\n")

  # Check if changes had been made for Remarks
  head(Bex$Remarks)

  # Count "No Remarks" and "Remarks"
  table_remarks <- table(ifelse(Bex$Remarks == "No Remarks", "No Remarks", "Remarks"))
  table_remarks
} else {
  cat("The 'NoRemarks' column already exists. No changes made.\n")
}



```

* Since **Remarks** contain information that could be distributed in other columns, corrections or additional information, I will explore and clean this variable now. 
* After the replacement of the NA's in Remarks with **No Remarks**, I found out that we have **614 Remarks** that I need to treat


```{r Remarks Exploration, echo=FALSE}

unique_remarks <- unique(Bex$Remarks)
head(unique_remarks)

library(dplyr)
library(stringr)
library(ggplot2)

# Define the keywords list properly before the loop
keywords <- c("open", "work", "trial", "approach", "scare", "intrude", "stole", "steal", "corn", "ate", "audience", "sec", "before", "after", "left", "na", "foraging", "alarm")

# Reinitialize to store updated counts
keyword_counts <- data.frame(Keyword = character(), Counts = integer(), stringsAsFactors = FALSE)

# Recalculate counts
for (kw in keywords) {
  count <- sum(str_detect(tolower(Bex$Remarks), kw))
  keyword_counts <- rbind(keyword_counts, data.frame(Keyword = kw, Counts = count))
}

# Plot with counts on bars
ggplot(keyword_counts, aes(x = reorder(Keyword, -Counts), y = Counts)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = Counts), hjust = -0.1, size = 3) +
  coord_flip() +
  labs(title = "Frequency of Keywords in Remarks (Excluding 'm', 'numerical value', '3 code letter', 'four code letter')", x = "Keyword", y = "Frequency") +theme_minimal()
```

* In order to ease the identification of key words in the remarks, I used an AI to analyze the **614 unique outputs of Remarks** to find some of the main keywords:


1. Equipment and Procedure Related
    - Keywords: "did not open", "opened early", "did not work", "first trial"
    - Examples: "Nge box did not open because of the battery", "opened seychelles box early by accident"
   
2. Animal Behavior Observations
    - Keywords: "approached", "did not approach", "scared", "intruded", "stole", "aggression", "tolerance"
    - Examples: "Sey came to the boxes once they were open", "Sirk was scared by Oerw", "oerw intruded"
  
3. Spatial Measurements and Corrections
    - Keywords: Measurements (e.g., "6m", "7m"), "distance"
    - Examples: "6m", "should have been 1m"
  
4. Specific Individual Actions or Reactions
    - Keywords: Names of individuals (e.g., "Sey", "Nge"), specific actions (e.g., "ate", "moved", "looked at")
    - Examples: "Nge and Oerw vo to MA", "Xia looked at piep"

5. Audience or Other Individual Involvement
    - Keywords: "audience", names of other individuals not part of the primary observation, "present"
    - Examples: "unknown audience", "Buk stole corn from Ndaw", "Juvenile also present"
   
6. Timing and Sequence of Events
    - Keywords: "before", "after", "when", "then"
    - Examples: "before aggression", "after 30 sec", "when he left she came"

7. Specific Observational Details or Corrections
    - Keywords: Specific observations (e.g., "ate all the corn"), corrections or clarifications
    - Examples: "Piep not approaching", "Piep box didn't open so they shared the corn in Xia box"

8. Miscellaneous or Unclear Remarks
    - Keywords: Ambiguous terms, unclear references
    - Examples: "na", "unknown audience", "contact calling in the background"
    - Action: These may require further clarification from the research team or might be categorized as 'miscellaneous' if they do not fit into other themes.
9. Technical or Environmental Notes
    - Keywords: "alarm", "left boxes on the ground", "foraging"
    - Examples: "There was an alarm and we left the boxes on the ground"
    - Action: Log these as environmental or technical notes that may have influenced the experiment.
    
* From this output I decided to explore the 508 **WHY 508 IF BEFORE I SAID  614** unique outputs of Remarks by identifying the **amount of lines and the rows where there are the following key words**: 
1. "open", "work", "trial"
2."approach", "scare", "intrude", "stole", "steal", "corn", "ate"
3. "numerical value", "m", "distance"
4. "3 code letter", "four code letter"
5. "audience", 
6. "sec", "before", "after", "left", 
7. "na", 
8. "foraging"
9. "alarm"


##### Vizualization of the Remarks Keywords
Before making any changes I will make a barplot of the main keywords in the column remarks to see what they are and in which proportion they are found. It has to be noted that some of the words are used in different contexts and have different meaning. This is why I will not create any rule from it





```{r Checking for keywords in Remarks, include=FALSE}
# Checking for keywords in Remarks
# Ensure the stringr package is installed and loaded
if (!require("stringr")) {
  install.packages("stringr")
  library(stringr)
}

# Ensure 'Remarks' is treated as a character column
Bex$Remarks <- as.character(Bex$Remarks)

# Define individual keywords as separate categories
keywords <- list(
  open = "open",
  work = "work",
  trial = "trial",
  approach = "approach",
  scare = "scare",
  intrude = "intrude",
  stole = "stole",
  steal = "steal",
  corn = "corn",
  ate = "ate",
  numerical_value_m = "\\b\\d+m\\b",  # Regex pattern for numerical value followed by 'm' (e.g., "6m")
  audience = "audience",
  sec = "sec",
  before = "before",
  after = "after",
  left = "left",
  na = "na",
  foraging = "foraging",
  alarm = "alarm"
)

# Modified function to find rows with keywords and print details
find_keyword_rows <- function(df, keyword) {
  rows <- which(str_detect(tolower(df$Remarks), keyword))
  if (length(rows) > 0) {
    for (row in rows) {
      print(paste("Keyword:", keyword, "- Row", row, ":", df$Remarks[row]))
    }
  }
  return(rows)
}

# Applying the modified function to each category
results <- lapply(keywords, function(kw) {
  rows <- find_keyword_rows(Bex, kw)
  return(unique(sort(rows)))
})

# Counting the number of lines for each category
line_counts <- sapply(results, length)


```

```{r Display amount key words, echo=FALSE}


# Ensure the knitr package is loaded for kable
library(knitr)

# Sort line_counts in descending order
sorted_line_counts <- sort(line_counts, decreasing = TRUE)

# Display the ordered results using kable
kable(sorted_line_counts, caption = "Counts of Keywords in Remarks (Ordered by Count)")

```


###### 2.3.1.2 Detailed cleaning of Remarks


* **Remarks - alarm (x1)**
 Row: **1816**
 
 -Here is the content of the column Remarks for row 1816: There was an alarm and we left the boxes on the ground. Kom came to the box and then left. Oort came and Kom came back immediately. No camera footage.

1. I want to create a column **Context** where every cell will be filled with "No Context"; this column will be used to insert any **information related to context as BGE, Aggression, Affiliative interaction and so on** when the context could be relevant
1.1 I want the line 1816 of "Context" to display "Alarm Event"
2. I want to create a column "Special behaviour" where every cell says "No"; this column will be used to insert any particular behaviour noted during the experiment as **Coming back to the box, getting robbed** and so on
2.1 I want the line 1816 of "Special behaviour" to says "Back to box; Kom"
3. I want to replace the line 1816 of "Remarks" with "Treated"
 
```{r Remarks - alarm, echo=FALSE}

# Check if "Context" and "SpecialBehaviour" columns exist, create if not
if (!"Context" %in% names(Bex)) {
  Bex$Context <- rep("No Context", nrow(Bex))
}

if (!"SpecialBehaviour" %in% names(Bex)) {
  Bex$SpecialBehaviour <- rep("No", nrow(Bex))
}

# Update row 1816 only if it hasn't been treated before
if (Bex$Remarks[1816] != "Treated") {
  Bex$Context[1816] <- "Alarm Event"
  Bex$SpecialBehaviour[1816] <- "Back to box;Kom"
  Bex$Remarks[1816] <- "Treated"
}

# Optional: View the modified rows (especially row 1816) to confirm the changes
print(Bex[1816, c("Remarks", "Context", "SpecialBehaviour")])

Bex_row_1816 <- Bex[1816, ]
print(Bex_row_1816)


```

* **Remarks - foraging (1x)**
  Row: **1892**
  
  -Here is the content of the column Remarks for row 1892:Monkeys are all actively foraging
  1. I want to put "Foraging" in the line 1892 of the column "Context"
  2. I want to put "Treated" in the column "Remarks" in line 1892
  3. I want to be sure the code is safe for multiple run
```{r Remarks - foraging,echo=FALSE}
# Ensure "Context" column exists, create if not
if (!"Context" %in% names(Bex)) {
  Bex$Context <- rep("No Context", nrow(Bex))
}

# Update row 1892 only if it hasn't been treated before
if (Bex$Remarks[1892] != "Treated") {
  Bex$Context[1892] <- "Foraging"
  Bex$Remarks[1892] <- "Treated"
}

# Optional: View the modified row (especially row 1892) to confirm the changes
print(Bex[1892, c("Remarks", "Context")])


Bex_row_1892 <- Bex[1892, ]
print(Bex_row_1892)

```



* **Remarks - scare (2x)**
  Row:**52 2249**
  
  -Here is the content of the column Remarks for row 52 and 2249: Sirk was scared by Oerw & oerw was scared to take the corn and nge ate her corn
   
  1. I want to put "Scared;Sirky by Oerw" in the line 52 of the column "SpecialBehaviour" and "Scared;Oerw by Nge" in the line 2249 of the same column
  2. I want to put "Intrusion" in the line 52 of the column "Context"
  3. I want to create a column called "Got Corn" that will display "Yes" in every row and replace the row 2249 by "No;Oerw"
  4. I want to put "Treated" in the column "Remarks" in line 52 and 2249 once the changes have been done
  5. I want to be sure the code is safe for multiple run even when using the row number
  
```{r Remarks - scare, echo=FALSE}
# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Create 'SpecialBehaviour' column if it doesn't exist
  if (!"SpecialBehaviour" %in% colnames(Bex)) {
    Bex$SpecialBehaviour <- rep("No", nrow(Bex))
  }
  
  # Create 'Context' column if it doesn't exist
  if (!"Context" %in% colnames(Bex)) {
    Bex$Context <- rep("No Context", nrow(Bex))
  }

  # Create 'Got Corn' column if it doesn't exist
  if (!"Got Corn" %in% colnames(Bex)) {
    Bex$`Got Corn` <- rep("Yes", nrow(Bex))
  }

  # Update 'SpecialBehaviour' only if it is "No"
  if (Bex$SpecialBehaviour[52] == "No") {
    Bex$SpecialBehaviour[52] <- "Scared;Sirky by Oerw"
  }
  if (Bex$SpecialBehaviour[2249] == "No") {
    Bex$SpecialBehaviour[2249] <- "Scared;Oerw by Nge"
  }

  # Update 'Context' only if it is "No Context"
  if (Bex$Context[52] == "No Context") {
    Bex$Context[52] <- "Intrusion"
  }

  # Update 'Got Corn' only if it is "Yes"
  if (Bex$`Got Corn`[2249] == "Yes") {
    Bex$`Got Corn`[2249] <- "No;Oerw"
  }

  # Update 'Remarks' only if it is not already "Treated"
  if (Bex$Remarks[52] != "Treated") {
    Bex$Remarks[52] <- "Treated"
  }
  if (Bex$Remarks[2249] != "Treated") {
    Bex$Remarks[2249] <- "Treated"
  }

  # View the modified rows
  Bex[c(52, 2249), ]
}

```


 * **Remarks - work (2x)**
   Rows: **95 2105**
   
   -Content of the column Remarks for rows concerned (2x): The box did not work
   1. I want to remove the rows 95 and 2105 of Bex and make the code safe for multiple run

```{r Remarks - work, echo=FALSE}
# Define the keyword for removal
keyword_to_remove <- "work"

# Find rows where the Remarks column contains the keyword
rows_to_remove <- which(str_detect(tolower(Bex$Remarks), keyword_to_remove))

# Check if the rows have already been removed
if (!all(is.na(Bex$Remarks[rows_to_remove]))) {
  # Remove rows where 'Remarks' contain 'work' and are not already NA
  Bex$Remarks[rows_to_remove] <- NA

  # Reporting
  num_rows_modified <- sum(!is.na(rows_to_remove))
  cat("Number of rows modified:", num_rows_modified, "\n")
} else {
  cat("No rows need modification.\n")
}

```

* **Remarks - not open (9x)**

  -Content of the column Remarks for rows concerned (9x): The box did not open 
  Rows: 320, 377, 632, 780, 899, 1360, 1445, 1652, 2209 
  
   1.(Audience)The remarks of the Row 321 indicated that some audience arrived:I want to replace the values in the column **Audience** of the row **320** and **321** with                **Sey;Piep;Sirk;Oup;Ome**

   2.(Got Corn) We will update the row called **Got corn** with new values:
   - Row **320**: put **No;Unk** in "Got Corn"
   - Row **377**: put **No;Kom** in "Got Corn"
   - Row **632**: put **No;Nge** in "Got Corn"
   - Row **780**: put **No;Oerw** in "Got Corn"
   - Row **899**: put **No;Xian** in "Got Corn"
   - Row **1360**: put **No;Xian** in "Got Corn"
   - Row **1445**: put **No;Sey** in "Got Corn"
   - Row **1652**: put **No;Sho** in "Got Corn"
   - Row **2209**: put **No;Piep** in "Got Corn"
   
   3.(Context) We will also update the column **Context** for the row **2209** by replacing the value by **Intrusion;Obse**
   



```{r Remarks - not open, echo=FALSE}
find_specific_phrase_in_remarks <- function(dataframe, phrase) {
    # Convert Remarks to lowercase for case-insensitive search and trim spaces
    dataframe$Remarks_lower <- tolower(trimws(dataframe$Remarks))
    
    # Pattern to match the specific phrase
    pattern <- paste0("\\b", phrase, "\\b")

    # Find rows where the Remarks column contains the phrase
    rows_with_phrase <- which(str_detect(dataframe$Remarks_lower, pattern))
    
    # Count the number of occurrences
    num_occurrences <- length(rows_with_phrase)
    
    # Return both the count and the rows
    return(list(count = num_occurrences, rows = rows_with_phrase))
}

# Search for the phrase "not open" in Remarks
results <- find_specific_phrase_in_remarks(Bex, "not open")

# Display the count of occurrences and the rows where "not open" is found
cat("Number of occurrences of 'not open':", results$count, "\n")
cat("Rows with 'not open':", toString(results$rows), "\n")

# Ensure Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Update 'Audience' values for rows 320 and 321 if they are not already updated
  # and if they are not NA
  if (!is.na(Bex$Audience[320]) && Bex$Audience[320] != "Sey;Piep;Sirk;Oup;Ome") {
    Bex$Audience[320] <- "Sey;Piep;Sirk;Oup;Ome"
  }
  if (!is.na(Bex$Audience[321]) && Bex$Audience[321] != "Sey;Piep;Sirk;Oup;Ome") {
    Bex$Audience[321] <- "Sey;Piep;Sirk;Oup;Ome"
  }

  # Update 'Got Corn' values for specific rows if they are not already updated
  got_corn_updates <- c("No;Unk", "No;Kom", "No;Nge", "No;Oerw", "No;Xian", 
                        "No;Xian", "No;Sey", "No;Sho", "No;Piep")
  rows_to_update_got_corn <- c(320, 377, 632, 780, 899, 1360, 1445, 1652, 2209)
  
  for (i in 1:length(rows_to_update_got_corn)) {
    row <- rows_to_update_got_corn[i]
    update <- got_corn_updates[i]
    if (Bex$`Got Corn`[row] != update) {
      Bex$`Got Corn`[row] <- update
    }
  }

  # Update 'Context' value for row 2209 if it is not already updated
  if (Bex$Context[2209] != "Intrusion;Obse") {
    Bex$Context[2209] <- "Intrusion;Obse"
  }

  # Optional: View the modified rows to confirm the changes
  print(Bex[c(320, 321, 377, 632, 780, 899, 1360, 1445, 1652, 2209), c("Audience", "Got Corn", "Context")])
}

```


* **Remarks - steal(8x)**
  Rows: 130, 417, 893, 909, 1070, 1344, 1393, 1947

  -Content: Attempts or success in stealing food
  
  1. I want to update the column **SpecialBehaviour** for the following columns
  - Row **130**: put **ASF;Buk** in "SpecialBehaviour"
  - Row **417**: put **ASF;Buk** in "SpecialBehaviour"
  - Row **893**: put **SF;Xian** in "SpecialBehaviour"
  - Row **909**: put **SF;Pom** in "SpecialBehaviour"
  - Row **1070**: put **ASF;Sey** in "SpecialBehaviour"
  - Row **1344**: put **ASF;Sey** in "SpecialBehaviour"
  - Row **1393**: put **ASF;Sey** in "SpecialBehaviour"
  - Row **1947**: put **ASF;Xia** in "Special Behaviour"
  
  2. I want to update the column **Got Corn** for the following columns
  - Row **417**; put **No;Kom** in "Got Corn"
  - Row **893**: put **No;Pom** in "Got Corn"
  - Row **909**: put **No;Xian** in "Got Corn"
  
  3. Replace the values that have been treated with **Treated** in the column "Remarks"
  
```{r Remarks - steal, echo=FALSE}

# Ensure the stringr package is installed and loaded
if (!require(stringr)) {
  install.packages("stringr")
  library(stringr)
}

# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define the keyword to search for in the Remarks column
  keyword <- "steal"

  # Find rows where the Remarks column contains the keyword (case-insensitive)
  rows_with_keyword <- which(str_detect(tolower(Bex$Remarks), tolower(keyword)))

  # Check if any rows were found
  if (length(rows_with_keyword) == 0) {
    cat("No occurrences of the keyword '", keyword, "' found in the Remarks column.\n")
  } else {
    # Print the rows that contain the keyword along with the row numbers
    for (row in rows_with_keyword) {
      print(paste("Row", row, ": ", Bex$Remarks[row]))
    }

    # Print the count of rows
    cat("Total number of occurrences of the keyword '", keyword, "': ", length(rows_with_keyword), "\n")
  }
}


# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Update 'SpecialBehaviour'
  special_behaviour_updates <- list(
    `130` = "ASF;Buk",
    `417` = "ASF;Buk",
    `893` = "SF;Xian",
    `909` = "SF;Pom",
    `1070` = "ASF;Sey",
    `1344` = "ASF;Sey",
    `1393` = "ASF;Sey",
    `1947` = "ASF;Xia"
  )
  
  for (row in names(special_behaviour_updates)) {
    if (Bex$SpecialBehaviour[as.numeric(row)] != special_behaviour_updates[[row]]) {
      Bex$SpecialBehaviour[as.numeric(row)] <- special_behaviour_updates[[row]]
    }
  }

  # Update 'Got Corn'
  got_corn_updates <- list(
    `417` = "No;Kom",
    `893` = "No;Pom",
    `909` = "No;Xian"
  )
  
  for (row in names(got_corn_updates)) {
    if (Bex$`Got Corn`[as.numeric(row)] != got_corn_updates[[row]]) {
      Bex$`Got Corn`[as.numeric(row)] <- got_corn_updates[[row]]
    }
  }

  # Replace 'Remarks' with 'Treated'
  rows_to_treat <- c(130, 417, 893, 909, 1070, 1344, 1393, 1947)
  for (row in rows_to_treat) {
    if (Bex$Remarks[row] != "Treated") {
      Bex$Remarks[row] <- "Treated"
    }
  }

  # Print the modified rows
  modified_rows <- unique(c(names(special_behaviour_updates), names(got_corn_updates), rows_to_treat))
  print(Bex[as.numeric(modified_rows), c("Remarks", "SpecialBehaviour", "Got Corn")])
}



```



* **Remarks - trial (8x)**
  Rows:98 660 860 962 1080 1082 1919 2773
  
```{r Remarks - trial, echo=FALSE}

# Ensure the stringr package is installed and loaded
if (!require(stringr)) {
  install.packages("stringr")
  library(stringr)
}

# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define the keyword to search for in the Remarks column
  keyword <- "trial"

  # Find rows where the Remarks column contains the keyword (case-insensitive)
  rows_with_keyword <- which(str_detect(tolower(Bex$Remarks), tolower(keyword)))

  # Check if any rows were found
  if (length(rows_with_keyword) == 0) {
    cat("No occurrences of the keyword '", keyword, "' found in the Remarks column.\n")
  } else {
    # Print the rows that contain the keyword along with the row numbers
    for (row in rows_with_keyword) {
      print(paste("Row", row, ": ", Bex$Remarks[row]))
    }

    # Print the count of rows
    cat("Total number of occurrences of the keyword '", keyword, "': ", length(rows_with_keyword), "\n")
  }
}

```

  -Content: Each row has to be treated in a unique way since this key word was not used in the same way for each trial
  
  1. Row **98**: put "First trial" in **Context** 
  2. Row **660**: put "Aggression" in **Context**
  3. Row **860**: put "Intrusion;Buk" in **Context**
  4. Row **962**: put "Buk;Ndaw" in **IdIndividual1** instead of "Buk"
  5. Row **1079** and **1080**: put "Oort" in **IntruderID**
  6. Row **1079** and **1080**: put "Intrusion;Oort" in **Context**
  7. Row **1082**: put "Mount;Xia" in **SpecialBehaviour**
  8. Row **1919**: delete the row
  9. Replace the Remarks for the rows 98,660,860,962,1080,1082,1919,2773 with **Treated**
  10.Make sure the code is safe for multiple run, especially when we delete a row
  11. Display these rows to check the changes


```{r Remarks - trial cleaning, echo=FALSE}
# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Ensure the column 'IDIndividual1' exists, add if not
  if (!"IDIndividual1" %in% names(Bex)) {
    Bex$IDIndividual1 <- NA
  }

  # Updates for specific rows
  if (98 <= nrow(Bex)) {
    Bex$Context[98] <- "First trial"
    Bex$Remarks[98] <- "Treated"
  }
  if (660 <= nrow(Bex)) {
    Bex$Context[660] <- "Aggression"
    Bex$Remarks[660] <- "Treated"
  }
  if (860 <= nrow(Bex)) {
    Bex$Context[860] <- "Intrusion;Buk"
    Bex$Remarks[860] <- "Treated"
  }
  if (962 <= nrow(Bex)) {
    Bex$IDIndividual1[962] <- "Buk;Ndaw"
    Bex$Remarks[962] <- "Treated"
  }
  if (1079 <= nrow(Bex)) {
    Bex$Context[1079] <- "Intrusion;Oort"
    Bex$IntruderID[1079] <- "Oort"
    Bex$Remarks[1079] <- "Treated"
  }
  if (1080 <= nrow(Bex)) {
    Bex$Context[1080] <- "Intrusion;Oort"
    Bex$IntruderID[1080] <- "Oort"
    Bex$Remarks[1080] <- "Treated"
  }
  if (1082 <= nrow(Bex)) {
    Bex$SpecialBehaviour[1082] <- "Mount;Xia"
    Bex$Remarks[1082] <- "Treated"
  }

  # Remove row 1919 if it exists
  if (1919 <= nrow(Bex)) {
    Bex <- Bex[-1919, ]
  }

  # Reset row names to maintain sequential order
  rownames(Bex) <- NULL

  # Display the modified rows (excluding the deleted row 1919)
  rows_to_display <- c(98, 660, 860, 962, 1079, 1080, 1082)
  rows_to_display <- rows_to_display[rows_to_display <= nrow(Bex)]
  print(Bex[rows_to_display, c("Remarks", "Context", "IDIndividual1", "IntruderID", "SpecialBehaviour")])
}

```


* **Remarks - numerical value (68x)**
  Rows:32, 33, 34, 35, 36, 37, 38, 39, 40, 49, 88, 89, 138, 159, 389, 392, 613, 851, 1090, 1176, 1178, 1180, 1277, 1338, 1473, 1481, 1545, 1575, 1595, 1624, 1692, 1700, 1701, 1706,      1796, 1807, 1815, 1866, 1870, 1874, 1882, 1915, 1925, 2038, 2039, 2059, 2062, 2066, 2098, 2127, 2140, 2148, 2162, 2166, 2194, 2220, 2270, 2312, 2348, 2382, 2397, 2445, 2471, 2491,     2548, 2591, 2631, 2745

```{r Remarks - Numerical value, echo=FALSE}

# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define the pattern to search for numerical values
  # The pattern \d+ matches one or more digits
  pattern <- "\\d+"

  # Find rows where the Remarks column contains the pattern (case-insensitive)
  rows_with_numerical_values <- which(str_detect(tolower(Bex$Remarks), pattern))

  # Check if any rows were found
  if (length(rows_with_numerical_values) == 0) {
    cat("No numerical values found in the Remarks column.\n")
  } else {
    # Print all the row numbers that contain numerical values
    cat("Rows with numerical values:", toString(rows_with_numerical_values), "\n")

    # Print the content of each row that contains numerical values
    for (row in rows_with_numerical_values) {
      print(paste("Row", row, ": ", Bex$Remarks[row]))
    }

    # Print the count of rows
    cat("Total number of occurrences of numerical values: ", length(rows_with_numerical_values), "\n")
  }
}

```


1. I want to replace the value in **DyadDistance** by the value that is found in "Remarks" for the following rows: **32, 33, 34, 35, 36, 37, 38, 39, 40**
2. Row **49**: Put "Scared;Sirk by Sey" in **SpecialBehaviour**
3. Row **88** and **89** replace the value in **DyadDistance** by "6m"
4. Row **138**: Put "SF;Oerw" in **SpecialBehaviour**
5. Row **389** and **392**: replace the value in **DyadDistance** by "1m"
6. Row **613**: Put "SF;Kom;1" in **SpecialBehaviour**
7. Row **1090**: replace the value in **DyadDistance** by "1m"
8. Row **1176**: Put "SF;Xian;1" in **SpecialBehaviour**
9. Row **1178**: replace the value in **DyadDistance** by "1m"
10. Row **1338**:Put "SF;Xia;2" in **SpecialBehaviour**
11. Row **1473**:Put "AP0;Gris" in **Context**
12. Row **1473**:Put "Xian;Pom" in **IDIndividual1**
13. Row **1595**: Put "SF;Sey" in **SpecialBehaviour**
14. Row **1701**: Put "SF;Gran" in **SpecialBehaviour**
15. Row **1701**: Put "Intrusion;Gran" in **Context**
16. Row **1796**: Put "No;Pom" in **Got Corn**
17. Row **1815**: Put "BGE" in **Context**
18. Row **1915**: Put "BGE" in **Context**
19. Row **2348**: Put "AP;MC" in **SpecialBehaviour**
20. Row **2591**: Put "SF;Gubh;Ndaw" in **SpecialBehaviour**
21. Row **2631**: Put "Aggression" in **DyadResponse**
22. Replace the values in the colum Remarks by "Treated" for these rows: **32, 33, 34, 35, 36, 37, 38, 39, 40, 49, 88, 89, 138, 159, 389, 392, 613, 851, 1090, 1176, 1178, 1180, 1277, 1338, 1473, 1545, 1575, 1595, 1624, 1692, 1700, 1701, 1706, 1796, 1807, 1815, 1866, 1870, 1874, 1882, 1915, 1925, 2038, 2039, 2059, 2062, 2066, 2098, 2127, 2140, 2148, 2162, 2166, 2194, 2220, 2270, 2312, 2348, 2382, 2397, 2445, 2471, 2491, 2548, 2591, 2631, 2745**
23. Make sure the code is safe for multiple run

```{r Remarks - Numerical Values  Cleaning, echo=FALSE}
# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Update DyadDistance based on the values found in Remarks for specific rows
  rows_for_dyaddistance_update <- c(32:40, 88, 89, 389, 392, 1090, 1178)
  for (row in rows_for_dyaddistance_update) {
    if (row <= nrow(Bex)) {
      new_value <- str_extract(Bex$Remarks[row], "\\d+m") # Extract numerical value followed by 'm'
      if (!is.na(new_value) && Bex$DyadDistance[row] != new_value) {
        Bex$DyadDistance[row] <- new_value
      }
    }
  }

  # Specific updates for rows
  special_behaviour_updates <- list(
    "49" = "Scared;Sirk by Sey",
    "138" = "SF;Oerw",
    "613" = "SF;Kom;1",
    "1176" = "SF;Xian;1",
    "1338" = "SF;Xia;2",
    "1595" = "SF;Sey",
    "1701" = "SF;Gran"
  )
  for (row in names(special_behaviour_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && Bex$SpecialBehaviour[row_num] != special_behaviour_updates[[row]]) {
      Bex$SpecialBehaviour[row_num] <- special_behaviour_updates[[row]]
    }
  }

  # Context, IDIndividual1, Got Corn updates
  context_updates <- c("1473" = "AP0;Gris", "1701" = "Intrusion;Gran", "1815" = "BGE", "1915" = "BGE")
  id_updates <- c("1473" = "Xian;Pom")
  got_corn_updates <- c("1796" = "No;Pom")
  
  for (row in names(context_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && Bex$Context[row_num] != context_updates[[row]]) {
      Bex$Context[row_num] <- context_updates[[row]]
    }
  }
  
  for (row in names(id_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && Bex$IDIndividual1[row_num] != id_updates[[row]]) {
      Bex$IDIndividual1[row_num] <- id_updates[[row]]
    }
  }

  for (row in names(got_corn_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && Bex$`Got Corn`[row_num] != got_corn_updates[[row]]) {
      Bex$`Got Corn`[row_num] <- got_corn_updates[[row]]
    }
  }

  # Replace values in the Remarks column by "Treated" for specific rows
  rows_for_remarks_update <- c(32:40, 49, 88, 89, 138, 159, 389, 392, 613, 851, 1090, 1176, 1178, 1180, 1277, 1338, 1473, 1545, 1575, 1595, 1624, 1692, 1700, 1701, 1706, 1796, 1807, 1815, 1866, 1870, 1874, 1882, 1915, 1925, 2038, 2039, 2059, 2062, 2066, 2098, 2127, 2140, 2148, 2162, 2166, 2194, 2220, 2270, 2312, 2348, 2382, 2397, 2445, 2471, 2491, 2548, 2591, 2631, 2745)
  for (row in rows_for_remarks_update) {
    if (row <= nrow(Bex) && Bex$Remarks[row] != "Treated") {
      Bex$Remarks[row] <- "Treated"
    }
  }

  # Display the modified rows to verify changes
  modified_rows <- unique(c(rows_for_dyaddistance_update, as.numeric(names(special_behaviour_updates)), as.numeric(names(context_updates)), as.numeric(names(id_updates)), as.numeric(names(got_corn_updates)), rows_for_remarks_update))
  modified_rows <- modified_rows[modified_rows <= nrow(Bex)]
  print(Bex[modified_rows, ])
}


```


* They are a certain amount of comments indicating than an individual came after 30 seconds, I decided for now to not treat them as I already have a lot of variables and this information even if important is not very consistent in the way it got reported
* I decided to keep row 1481 as it is to see how to treat it later


* **Remarks - intrude (26x)**
  Rows: 136, 142, 600, 618, 804, 936, 1011, 1012, 1069, 1113, 1174, 1257, 1258, 1271, 1272, 1299, 1370, 1486, 1533, 1880, 1920, 2221, 2372, 2376, 2687, 2769 
  
  -Content: Rows where an individual intruded or attempted to make an intrusion during a trial
  
```{r Remarks - intrude, echo=FALSE}
# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define the keyword to search for in the Remarks column
  keyword <- "intrude"

  # Find rows where the Remarks column contains the keyword (case-insensitive)
  rows_with_keyword <- which(str_detect(tolower(Bex$Remarks), tolower(keyword)))

  # Check if any rows were found
  if (length(rows_with_keyword) == 0) {
    cat("No occurrences of the keyword '", keyword, "' found in the Remarks column.\n")
  } else {
    # Print all the row numbers that contain the keyword
    cat("Rows with the keyword '", keyword, "':", toString(rows_with_keyword), "\n")

    # Print the content of each row that contains the keyword
    for (row in rows_with_keyword) {
      print(paste("Row", row, ": ", Bex$Remarks[row]))
    }

    # Print the count of rows
    cat("Total number of occurrences of the keyword '", keyword, "': ", length(rows_with_keyword), "\n")
  }
}

```


 1. Row **136**: Put "Oerw" in **IntruderID** and "Intrusion;Oerw" in **Context**
 2. Row **142**: Put "AttemptIntrusion;Kom" in **Context**
 3. Row **600**: Put "Intrusion;Obse" in **Context**
 4. Row **618**: Put "Kom" in **IntruderID** and "Intrusion;Kom" in **Context**
 5. Row **618**: Put "Yes;Sirk;1" in the column **GotCorn**
 6. Row **804**: Put "Sho" in the column **IntruderID** and "Intrusion;Sho" in **Context**
 7. Row **936**: Put "Oerw;Oupa" in the column **IntruderID** and "Intrusion;Oerw;Oupa" in **Context**
 8. Row **1011**: Put "Obse" in the column **IntruderID** and "Intrusion;Obse" in **Context**
 9. Row **1011**: Put "No;Piep" in the column **GotCorn**
 10.Row **1012**: Put "Obse" in the column **IntruderID** and "Intrusion;Obse" in **Context**
 11.Row **1012**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
 12.Row **1069**: Put "Oort" in **IntruderID** and "Intrusion;Oort" in **Context**
 13.Row **1113**: Put "Oort" in **IntruderID** and "ST;Oort;Sirk" in **Context**
 14.Row **1174**: Put "AttemptIntrusion;Gaya" in **Context**
 15.Row **1257**: Put "Obse" in **IntruderID** and "Intrusion;Obse" in **Context**
 16.Row **1258**: Put "Obse;Sey" in **IntruderID** and "Intrusion;Obse;Sey" in **Context**
 17.Row **1271**: Put "Piep" in **IntruderID** and "Intrusion;Piep" in **Context**
 18.Row **1272**: Put "Piep" in **IntruderID** and "Intrusion;Piep" in **Context**
 19.Row **1299**: Put "Gri" in **IntruderID** and "Intrusion;Gri" in **Context**
 20.Row **1370**: Put "Oort" in **IntruderID** and "Intrusion;Oort" in **Context**
 21.Row **1486**: Put "Sey" in **IntruderID** and "Intrusion;Sey" in **Context**
 22.Row **1533**: Put "AttemptIntrusion;Xia" in **Context**
 23.Row **1880**: Put "Ghid" in **IntruderID** and "Intrusion;Ghid" in **Context**
 24.Row **1880**: Put "Sho;Ginq" in **IdIndividual1**
 25.Row **1920**: Put "Oerw" in **IntruderID** and "Intrusion;Oerw" in **Context**
 26.Row **2221**: Put "Oerw" in **IntruderID** and "Intrusion;Oerw" in **Context**
 27.Row **2372**: Put "Buk" in **IntruderID** and "Intrusion;Buk" in **Context**
 28.Row **2376**: Put "Buk" in **IntruderID** and "Intrusion;Buk" in **Context**
 29.Row **2687**: Put "Tolerance;Intrusion" in **DyadResponse**
 30.Row **2687**: Put "Oerw" in **IntruderID** and "Intrusion;Oerw" in **Context**
 31.Row **2769**: Put "Sey" in **IntruderID** and "Intrusion;Sey" in **Context**
 32. Make sure the code is safe for multiple run and check for any syntax error
 
```{r Remarks - intrude cleaning, echo=FALSE}

# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  library(stringr)

  # Define updates for IntruderID and Context
  intruderID_updates <- c("136" = "Oerw", "618" = "Kom", "804" = "Sho", "936" = "Oerw;Oupa", 
                          "1011" = "Obse", "1012" = "Obse", "1069" = "Oort", "1113" = "Oort", 
                          "1257" = "Obse", "1258" = "Obse;Sey", "1271" = "Piep", "1272" = "Piep", 
                          "1299" = "Gri", "1370" = "Oort", "1486" = "Sey", "1880" = "Ghid", 
                          "1920" = "Oerw", "2221" = "Oerw", "2372" = "Buk", "2376" = "Buk", 
                          "2687" = "Oerw", "2769" = "Sey")
  context_updates <- c("136" = "Intrusion;Oerw", "142" = "AttemptIntrusion;Kom", "600" = "Intrusion;Obse", 
                       "618" = "Intrusion;Kom", "804" = "Intrusion;Sho", "936" = "Intrusion;Oerw;Oupa", 
                       "1011" = "Intrusion;Obse", "1012" = "Intrusion;Obse", "1069" = "Intrusion;Oort", 
                       "1113" = "ST;Oort;Sirk", "1174" = "AttemptIntrusion;Gaya", "1257" = "Intrusion;Obse", 
                       "1258" = "Intrusion;Obse;Sey", "1271" = "Intrusion;Piep", "1272" = "Intrusion;Piep", 
                       "1299" = "Intrusion;Gri", "1370" = "Intrusion;Oort", "1486" = "Intrusion;Sey", 
                       "1533" = "AttemptIntrusion;Xia", "1880" = "Intrusion;Ghid", "1920" = "Intrusion;Oerw", 
                       "2221" = "Intrusion;Oerw", "2372" = "Intrusion;Buk", "2376" = "Intrusion;Buk", 
                       "2687" = "Tolerance;Intrusion", "2769" = "Intrusion;Sey")

  # Apply updates for IntruderID and Context
  for (row in names(intruderID_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && !is.na(Bex$Remarks[row_num])) {
      Bex$IntruderID[row_num] <- intruderID_updates[[row]]
      Bex$Context[row_num] <- context_updates[[row]]
    }
  }

  # Additional updates as previously defined (SpecialBehaviour, Got Corn, IDIndividual1, etc.)
  # ...

  # Update DyadDistance based on values in Remarks
  rows_for_dyaddistance_update <- c(32:40, 88, 89, 389, 392, 1090, 1178)
  for (row in rows_for_dyaddistance_update) {
    if (row <= nrow(Bex)) {
      new_value <- str_extract(Bex$Remarks[row], "\\d+m") # Extract numerical value followed by 'm'
      if (!is.na(new_value) && Bex$DyadDistance[row] != new_value) {
        Bex$DyadDistance[row] <- new_value
      }
    }
  }

  # Replace values in the Remarks column by "Treated" for specified rows
  rows_for_remarks_update <- c(32:40, 49, 88, 89, 138, 159, 389, 392, 613, 851, 1090, 1176, 1178, 1180, 1277, 1338, 1473, 1545, 1575, 1595, 1624, 1692, 1700, 1701, 1706, 1796, 1807, 1815, 1866, 1870, 1874, 1882, 1915, 1925, 2038, 2039, 2059, 2062, 2066, 2098, 2127, 2140, 2148, 2162, 2166, 2194, 2220, 2270, 2312, 2348, 2382, 2397, 2445, 2471, 2491, 2548, 2591, 2631, 2745)
  for (row in rows_for_remarks_update) {
    if (row <= nrow(Bex) && Bex$Remarks[row] != "Treated") {
      Bex$Remarks[row] <- "Treated"
    }
  }

  # Display modified rows to verify changes
  modified_rows <- unique(c(rows_for_dyaddistance_update, as.numeric(names(special_behaviour_updates)), as.numeric(names(context_updates)), as.numeric(names(id_updates)), as.numeric(names(got_corn_updates)), rows_for_remarks_update))
  modified_rows <- modified_rows[modified_rows <= nrow(Bex)]
  print(Bex[modified_rows, ])
}


```

 
* **Remarks - open ( x)**
  Rows: 3, 4, 12, 247, 280, 406, 419, 490, 768, 798, 924, 938, 991, 1076, 1114, 1127, 1211, 1330, 1331, 1432, 1452, 1466, 1472, 1523, 1526, 1585, 1710, 1785, 1827, 1971, 2037, 2107,     2178, 2192, 2370, 2384, 2472, 2676 
  
  -Content: Mostly cases where one or the two boxes did not open
  
```{r Remarks - open, echo=FALSE}
# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define the keyword to search for in the Remarks column
  keyword <- "open"

  # Find rows where the Remarks column contains the keyword (case-insensitive)
  rows_with_keyword <- which(str_detect(tolower(Bex$Remarks), tolower(keyword)))

  # Check if any rows were found
  if (length(rows_with_keyword) == 0) {
    cat("No occurrences of the keyword '", keyword, "' found in the Remarks column.\n")
  } else {
    # Print all the row numbers that contain the keyword
    cat("Rows with the keyword '", keyword, "':", toString(rows_with_keyword), "\n")

    # Print the content of each row that contains the keyword
    for (row in rows_with_keyword) {
      print(paste("Row", row, ": ", Bex$Remarks[row]))
    }

    # Print the count of rows
    cat("Total number of occurrences of the keyword '", keyword, "': ", length(rows_with_keyword), "\n")
  }
}

```

1.Row **3**: Put "No;Nge" in **GotCorn**
2.Row **12**: Put "VO;Oerw;RT;NGE" in **SpecialBehaviour** 
3.Row **247**: Delete the row
4.Row **280**: Put "No;Xian" in **GotCorn**
5.Row **280**: Put "Aggression;Pom" in **Context**
6.Row **419**: Put "No;Pom" in **GotCorn**
7.Row **490**: Put "SF;Xia" in **SpecialBehaviour**
8.Row **490**: Put "No;Piep" in **GotCorn**
9.Row **768**: Put "No;Kom" in **GotCorn**
10.Row **798**: Delete the row
11.Row **938**: Put "No;Kom" in **GotCorn**
12.Row **991**: Put "No;Sey" in **GotCorn**
13.Row **991**: Put "Obse" in **IntruderID** and "Intrusion;Obse" in **Context**
14.Row **1076**: Put "EatSameBox" in **SpecialBehaviour**
15.Row **1114**: Put "No;Xian" in **GotCorn**
16.Row **1211**: Put "No;Piep" in **GotCorn**
17.Row **1330**: Put "No;Kom" in **GotCorn**
18.Row **1331**: Put "No;Kom" in **GotCorn** and "SF;Oort" in **SpecialBehaviour**
19.Row **1432**: Put "No;Kom" in **GotCorn**
20.Row **1432**: Put "Sey" in **IntruderID**
21.Row **1452**: Put "No;Sey" in **GotCorn**
22.Row **1466**: Put "No;Piep" in **GotCorn**
23.Row **1523**: Put "No;Pom" in **GotCorn**
24.Row **1526**: Put "No;Pom" in **GotCorn**
25.Row **1526**: Put "AP;Pom;FL;Xian" in **SpecialBehaviour**
26.Row **1585**: Delete Row
27.Row **1785**: Put "No;Pom" in **GotCorn**
28.Row **1971**: Put "No;Oerw" in **GotCorn**
29.Row **2037**: Put "No;Piep" in **GotCorn** and "SF;Xia" in **SpecialBehaviour**
30.Row **2370**: Put "No;Sho" in **GotCorn**
31.Row **2472**: Put "No;Ginq" in **GotCorn**
32.Row **2676**: Put "No;Piep" in **GotCorn**
33.Check for multiple run especially for the rows that will have been deleted and display the rows that have ben changed
34.Replace the remarks by "Treated" for the following rows:3, 4, 12, 247, 280, 406, 419, 490, 768, 798, 924, 938, 991, 1076, 1114, 1127, 1211, 1330, 1331, 1432, 1452, 1466, 1472, 1523, 1526, 1585, 1710, 1785, 1827, 1971, 2037, 2107, 2178, 2192, 2370, 2384, 2472, 2676 


```{r Remarks - open cleaning, echo=FALSE}

# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define updates for each column
  got_corn_updates <- c("3" = "No;Nge", "12" = "VO;Oerw;RT;NGE", "280" = "No;Xian", "419" = "No;Pom", "490" = "SF;Xia", "768" = "No;Kom", "938" = "No;Kom", "991" = "No;Sey", "1076" = "EatSameBox", "1114" = "No;Xian", "1211" = "No;Piep", "1330" = "No;Kom", "1331" = "No;Kom", "1432" = "No;Kom", "1452" = "No;Sey", "1466" = "No;Piep", "1523" = "No;Pom", "1526" = "No;Pom", "1785" = "No;Pom", "1971" = "No;Oerw", "2037" = "No;Piep", "2370" = "No;Sho", "2472" = "No;Ginq", "2676" = "No;Piep")
  special_behaviour_updates <- c("12" = "VO;Oerw;RT;NGE", "490" = "SF;Xia", "1331" = "SF;Oort", "1526" = "AP;Pom;FL;Xian", "2037" = "SF;Xia")
  intruder_id_updates <- c("991" = "Obse", "1432" = "Sey")
  context_updates <- c("280" = "Aggression;Pom", "991" = "Intrusion;Obse")

  # Apply updates
  for (row in names(got_corn_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && !is.na(Bex$`Got Corn`[row_num]) && Bex$`Got Corn`[row_num] != got_corn_updates[[row]]) {
      Bex$`Got Corn`[row_num] <- got_corn_updates[[row]]
    }
  }

  for (row in names(special_behaviour_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && !is.na(Bex$SpecialBehaviour[row_num]) && Bex$SpecialBehaviour[row_num] != special_behaviour_updates[[row]]) {
      Bex$SpecialBehaviour[row_num] <- special_behaviour_updates[[row]]
    }
  }

  for (row in names(intruder_id_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && !is.na(Bex$IntruderID[row_num]) && Bex$IntruderID[row_num] != intruder_id_updates[[row]]) {
      Bex$IntruderID[row_num] <- intruder_id_updates[[row]]
    }
  }

  for (row in names(context_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && !is.na(Bex$Context[row_num]) && Bex$Context[row_num] != context_updates[[row]]) {
      Bex$Context[row_num] <- context_updates[[row]]
    }
  }

  # Delete rows only if they exist
  rows_to_delete <- c(247, 798, 1585)
  rows_to_delete <- rows_to_delete[rows_to_delete <= nrow(Bex)]
  Bex <- Bex[-rows_to_delete, ]

  # Replace 'Remarks' values with 'Treated' for specific rows if not already done
  rows_for_remarks_update <- c(3, 12, 280, 419, 490, 768, 938, 991, 1076, 1114, 1211, 1330, 1331, 1432, 1452, 1466, 1523, 1526, 1785, 1971, 2037, 2370, 2472, 2676)
  for (row in rows_for_remarks_update) {
    if (row <= nrow(Bex) && Bex$Remarks[row] != "Treated") {
      Bex$Remarks[row] <- "Treated"
    }
  }

  # Display modified rows
  modified_rows <- unique(c(as.numeric(names(got_corn_updates)), as.numeric(names(special_behaviour_updates)), as.numeric(names(intruder_id_updates)), as.numeric(names(context_updates)), rows_for_remarks_update))
  modified_rows <- modified_rows[modified_rows <= nrow(Bex)]
  print(Bex[modified_rows, ])
}


```

* **Remarks - audience (43x)**
  Rows:72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 103, 104, 105, 106, 107, 108, 109, 110, 787, 1877, 2767, 2768, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779,       2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787 
  
  -Content: Mostly cases where the audience was unknown

```{r, Remarks - audience, echo=FALSE}
# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define the keyword to search for in the Remarks column
  keyword <- "audience"

  # Find rows where the Remarks column contains the keyword (case-insensitive)
  rows_with_keyword <- which(str_detect(tolower(Bex$Remarks), tolower(keyword)))

  # Check if any rows were found
  if (length(rows_with_keyword) == 0) {
    cat("No occurrences of the keyword '", keyword, "' found in the Remarks column.\n")
  } else {
    # Print all the row numbers that contain the keyword
    cat("Rows with the keyword '", keyword, "':", toString(rows_with_keyword), "\n")

    # Print the content of each row that contains the keyword
    for (row in rows_with_keyword) {
      print(paste("Row", row, ": ", Bex$Remarks[row]))
    }

    # Print the count of rows
    cat("Total number of occurrences of the keyword '", keyword, "': ", length(rows_with_keyword), "\n")
  }
}
```

1.Row **2786**: Put "ASF;Sey" in **SpecialBehaviour**
2.Rows:**72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 103, 104, 105, 106, 107, 108, 109, 110, 2767, 2768, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787**, replace the NA's by "No Audience" in the column **Audience**
3.Row **1877**: Put "No Audience" in **Audience**
4.Replace the remarks by "Treated" for the rows: **72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 103, 104, 105, 106, 107, 108, 109, 110, 787, 1877, 2767, 2768, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787** 
5.Make sure the code is safe for multiple run and display the lines where changes have been made


```{r Remarks - Audience cleaning, echo=FALSE}
# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Update SpecialBehaviour for Row 2786
  if (2786 <= nrow(Bex) && Bex$SpecialBehaviour[2786] != "ASF;Sey") {
    Bex$SpecialBehaviour[2786] <- "ASF;Sey"
  }

  # Rows to update 'Audience' column
  audience_rows <- c(72:85, 103:110, 1877, 2767:2787)

  # Replace NA's with "No Audience" in 'Audience' column
  for (row in audience_rows) {
    if (row <= nrow(Bex) && is.na(Bex$Audience[row])) {
      Bex$Audience[row] <- "No Audience"
    }
  }

  # Rows to update 'Remarks' column with 'Treated'
  remarks_rows <- c(72:85, 103:110, 787, 1877, 2767:2787)

  # Replace 'Remarks' values with 'Treated'
  for (row in remarks_rows) {
    if (row <= nrow(Bex) && Bex$Remarks[row] != "Treated") {
      Bex$Remarks[row] <- "Treated"
    }
  }

  # Display the modified rows to verify changes
  modified_rows <- unique(c(2786, audience_rows, remarks_rows))
  modified_rows <- modified_rows[modified_rows <= nrow(Bex)]
  print(Bex[modified_rows, ])
}


```

* **Remarks - approach (58x)**
  Rows: 325, 348, 520, 792, 865, 869, 890, 920, 984, 1020, 1133, 1256, 1258, 1266, 1378, 1402, 1404, 1406, 1428, 1467, 1518, 1519, 1522, 1573, 1613, 1629, 1630, 1637, 1697, 1750,        1878,1895, 1902, 1904, 1951, 1983, 2095, 2140, 2141, 2143, 2171, 2172, 2198, 2212, 2230, 2260, 2277, 2327, 2378, 2593, 2683, 2688, 2710, 2719, 2757 
  
  -Content: Mostly cases where individuals did not approach or approached to late

```{r Remarks - approach, echo=FALSE}

# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define the keyword to search for in the Remarks column
  keyword <- "approach"

  # Find rows where the Remarks column contains the keyword (case-insensitive)
  rows_with_keyword <- which(str_detect(tolower(Bex$Remarks), tolower(keyword)))

  # Check if any rows were found
  if (length(rows_with_keyword) == 0) {
    cat("No occurrences of the keyword '", keyword, "' found in the Remarks column.\n")
  } else {
    # Print all the row numbers that contain the keyword
    cat("Rows with the keyword '", keyword, "':", toString(rows_with_keyword), "\n")

    # Print the content of each row that contains the keyword
    for (row in rows_with_keyword) {
      print(paste("Row", row, ": ", Bex$Remarks[row]))
    }

    # Print the count of rows
    cat("Total number of occurrences of the keyword '", keyword, "': ", length(rows_with_keyword), "\n")
  }
}


```

1.Row **520**: Replace NA by "Piep" in **IDIndividual1**
2.Row **865**: Put "SF;Buk;SC;Ndaw" in **SpecialBehaviour**
3.Row **1428**: Put "No;Kom" in **GotCorn**
4.Row **1522**: Put "No;Pom;Xian" in **GotCorn**
5.Row **1522**: Put "AP;Pom;FL;Xian" in **SpecialBehaviour**
6.Row **1637**: Put "Obse" in **IntruderID** and "Intrusion;Obse" in **Context**
7.Row **1697**: Put "Gris" in **IntruderID** and "Intrusion;Obse" in **Context**
8.Row **1697**: Put "No;Pom;Xian" in **GotCorn**
9.Row **1750**: Put "No;Xian" in **GotCorn**
10.Row **1951**: Put "AT;Sho;Ghid" in **SpecialBehaviour**
11.Row **2141**: Put "Buk;Ndaw" in **IDIndividual1**
12.Row **2141**: Put "Resting" in **Context**
13.Row **2171**: Put "Buk;Ndaw" in **IDIndividual1**
13.Row **2172**: Put "Buk;Ndaw" in **IDIndividual1**
14. Row **2593**: Put "AP;Sey;JA;Sirk" in **SpecialBehaviour**
15. Row **2683**: Put "Intrusion" in **DyadResponse** and "Obse" in **IntruderID** and "Intrusion;Obse" in **Context**
16. Row **2688**: Put "AP;Sey;JA;Sirk" in **SpecialBehaviour**
17. Replace the Remarks by "Treated" in the rows: 325, 348, 520, 792, 865, 869, 890, 920, 984, 1020, 1133, 1256, 1258, 1266, 1378, 1402, 1404, 1406, 1428, 1467, 1518, 1519, 1522, 1573, 1613, 1629, 1630, 1637, 1697, 1750, 1878, 1895, 1902, 1904, 1951, 1983, 2095, 2140, 2141, 2143, 2171, 2172, 2198, 2212, 2230, 2260, 2277, 2327, 2378, 2593, 2683, 2688, 2710, 2719, 2757 18. Make sure the code is safe for multiple run and display the rows where changes where made

```{r Remarks - approach cleaning, echo=FALSE}

# Check if Bex dataframe is available
if (!("Bex" %in% ls())) {
  cat("Error: Dataframe 'Bex' not found.\n")
} else {
  # Define updates for each column
  id_ind1_updates <- c("520" = "Piep", "2141" = "Buk;Ndaw", "2171" = "Buk;Ndaw", "2172" = "Buk;Ndaw")
  special_behaviour_updates <- c("865" = "SF;Buk;SC;Ndaw", "1522" = "AP;Pom;FL;Xian", "1951" = "AT;Sho;Ghid", "2593" = "AP;Sey;JA;Sirk", "2688" = "AP;Sey;JA;Sirk")
  got_corn_updates <- c("1428" = "No;Kom", "1522" = "No;Pom;Xian", "1697" = "No;Pom;Xian", "1750" = "No;Xian")
  intruder_id_updates <- c("1637" = "Obse", "1697" = "Gris", "2683" = "Obse")
  context_updates <- c("1637" = "Intrusion;Obse", "1697" = "Intrusion;Obse", "2141" = "Resting", "2683" = "Intrusion;Obse")
  dyad_response_updates <- c("2683" = "Intrusion")

  # Apply updates to the Bex dataframe
  for (row in names(id_ind1_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && (is.na(Bex$IDIndividual1[row_num]) || Bex$IDIndividual1[row_num] != id_ind1_updates[[row]])) {
      Bex$IDIndividual1[row_num] <- id_ind1_updates[[row]]
    }
  }

  for (row in names(special_behaviour_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && (is.na(Bex$SpecialBehaviour[row_num]) || Bex$SpecialBehaviour[row_num] != special_behaviour_updates[[row]])) {
      Bex$SpecialBehaviour[row_num] <- special_behaviour_updates[[row]]
    }
  }

  for (row in names(got_corn_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && (is.na(Bex$`Got Corn`[row_num]) || Bex$`Got Corn`[row_num] != got_corn_updates[[row]])) {
      Bex$`Got Corn`[row_num] <- got_corn_updates[[row]]
    }
  }

  for (row in names(intruder_id_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && (is.na(Bex$IntruderID[row_num]) || Bex$IntruderID[row_num] != intruder_id_updates[[row]])) {
      Bex$IntruderID[row_num] <- intruder_id_updates[[row]]
    }
  }

  for (row in names(context_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && (is.na(Bex$Context[row_num]) || Bex$Context[row_num] != context_updates[[row]])) {
      Bex$Context[row_num] <- context_updates[[row]]
    }
  }

  for (row in names(dyad_response_updates)) {
    row_num <- as.numeric(row)
    if (row_num <= nrow(Bex) && (is.na(Bex$DyadResponse[row_num]) || Bex$DyadResponse[row_num] != dyad_response_updates[[row]])) {
      Bex$DyadResponse[row_num] <- dyad_response_updates[[row]]
    }
  }

  # Replace 'Remarks' values with 'Treated'
  rows_for_remarks_update <- c(325, 348, 520, 792, 865, 869, 890, 920, 984, 1020, 1133, 1256, 1258, 1266, 1378, 1402, 1404, 1406, 1428, 1467, 1518, 1519, 1522, 1573, 1613, 1629, 1630, 1637, 1697, 1750, 1878, 1895, 1902, 1904, 1951, 1983, 2095, 2140, 2141, 2143, 2171, 2172, 2198, 2212, 2230, 2260, 2277, 2327, 2378, 2593, 2683, 2688, 2710, 2719, 2757)
  for (row in rows_for_remarks_update) {
    if (row <= nrow(Bex) && Bex$Remarks[row] != "Treated") {
      Bex$Remarks[row] <- "Treated"
    }
  }

  # Display modified rows
  modified_rows <- unique(c(as.numeric(names(id_ind1_updates)), as.numeric(names(special_behaviour_updates)), as.numeric(names(got_corn_updates)), as.numeric(names(intruder_id_updates)), as.numeric(names(context_updates)), as.numeric(names(dyad_response_updates)), rows_for_remarks_update))
  modified_rows <- modified_rows[modified_rows <= nrow(Bex)]
  print(Bex[modified_rows, ])
}


```
* **Remarks - corn (119x)**
  Rows:28, 158, 225, 425, 483, 491, 517, 531, 541, 635, 770, 794, 795, 811, 812, 813, 899, 910, 916, 917, 918, 927, 963, 965, 967, 968, 969, 971, 977, 978, 1010, 1013, 1033, 1038,       1039, 1040, 1041, 1044, 1057, 1072, 1073, 1079, 1080, 1087, 1116, 1120, 1134, 1204, 1207, 1245, 1265, 1289, 1335, 1337, 1339, 1343, 1350, 1352, 1353, 1354, 1357, 1438, 1459, 1511,     1514, 1525, 1536, 1537, 1550, 1551, 1569, 1617, 1639, 1640, 1642, 1741, 1777, 1778, 1885, 1894, 2031, 2035, 2052, 2089, 2090, 2123, 2135, 2244, 2245, 2253, 2254, 2313, 2316, 2341,     2346, 2364, 2382, 2386, 2436, 2442, 2466, 2471, 2479, 2484, 2490, 2515, 2548, 2549, 2559, 2601, 2609, 2621, 2626, 2670, 2675, 2722, 2738, 2741, 2748 
  
  -Content:Cases where one invidual got the corn stolen or did not get it


```{r Remarks - ate, echo=FALSE}

# Define the keyword to search for in the Remarks column
keyword <- "corn"

# Find rows where the Remarks column contains the keyword (case-insensitive)
rows_with_keyword <- which(str_detect(tolower(Bex$Remarks), tolower(keyword)))

# Print all the row numbers that contain the keyword and their content
if (length(rows_with_keyword) > 0) {
  cat("Rows with the keyword '", keyword, "':", toString(rows_with_keyword), "\n")
  for (row in rows_with_keyword) {
    print(paste("Row", row, ": ", Bex$Remarks[row]))
  }
  cat("Total number of occurrences of the keyword '", keyword, "': ", length(rows_with_keyword), "\n")
} else {
  cat("No occurrences of the keyword '", keyword, "' found in the Remarks column.\n")
}

View(Bex)


```

1.Row **228**: Put "No;Piep" in **GotCorn**
2.Row **158**: Put "Female aggress male;Male aggress male" in **DyadResponse**
3.Row **158**: Put "No;Oort" in **GotCorn** and **SF;Sey** in **Context**
4.Row **225**: Put "No;Xian" in **GotCorn**
5.Row **425**: Put "No;Xian" in **GotCorn**
6.Row **483**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn**
7.Row **491**: Put "SF;Kom" in **SpecialBehaviour** and "No;Oort" in **GotCorn** 
8.Row **517**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
9.Row **531**: Put "No;Piep" in **GotCorn**
10.Row **541**: Put "SF;Sey" in **SpecialBehaviour** and "No;Sirk" in **GotCorn**
11.Row **770**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
12.Row **794**: Put "SF;Buk" in **SpecialBehaviour** and "No;Ndaw" in **GotCorn**
13.Row **795**: Put "SF;Buk" in **SpecialBehaviour** and "No;Ndaw" in **GotCorn**
14.Row **811**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
15.Row **812**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
16.Row **813**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
17.Row **899**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom;1" in **GotCorn**
18.Row **910**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
19.Row **916**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
20.Row **917**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn**
21.Row **918**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
22.Row **927**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn**
23.Row **963**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn**
24.Row **965**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn**
25.Row **967**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
26.Row **968**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
27.Row **969**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn**
28.Row **971**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
29.Row **977**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom;1" in **GotCorn**

``` {r Remarks - ate 1-29, echo=FALSE}




```


30.Row **978**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom;2" in **GotCorn**
31.Row **1010**: Put "SF;Piep" in **SpecialBehaviour** and "No;Xia" in **GotCorn**
32.Row **1013**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
33.Row **1038**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn**
34.Row **1039**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn**
35.Row **1040**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn**
36.Row **1041**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn**
37.Row **1044**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom;1" in **GotCorn**
38.Row **1057**: Put "Yes;CornFell" in **GotCorn**
39.Row **1072**: Put "EatSameBox" in **SpecialBehaviour**
40.Row **1073**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
41.Row **1079**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
42.Row **1080**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn**
43.Row **1079**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn**
44.Row **1080**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn** 
45.Row **1087**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom" in **GotCorn**
46.Row **1116**: Put "SF;Pom" in **SpecialBehaviour** and "No;Xian" in **GotCorn**
47.Row **1120**: Put "SF;Pom" in **SpecialBehaviour** and "No;Xian" in **GotCorn**
48.Row **1134**: Put "No;Buk" in **GotCorn**
49.Row **1204**: Put "No;Piep" in **GotCorn**
50.Row **1207**: Put "No;Piep" in **GotCorn**


51.Row **1245**: Put "No;Piep" in **GotCorn**
52.Row **1265**: Put "SF;Buk" in **SpecialBehaviour** and "No;Ndaw;1" in **GotCorn**
53.Row **1289**: Put "No;Buk" in **GotCorn**
54.Row **1335**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
55.Row **1337**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
56.Row **1339**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
57.Row **1343**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
58.Row **1350**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn** 
59.Row **1352**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;2" in **GotCorn** 
60.Row **1353**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;2" in **GotCorn** 
61.Row **1354**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;2" in **GotCorn** 
62.Row **1438**: Put "SF;Oort" in **SpecialBehaviour** and "No;Kom;1" in **GotCorn**
63.Row **1459**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn**
64.Row **1511**: Put "No;Xian" in **GotCorn**
65.Row **1511**: Put "Tolerance;Intrusion" in **DyadResponse** and "Gree;Gran" in **IntruderID**
66.Row **1511**: Put "Intrusion;Gree;Gran" in **SpecialBehaviour**
67.Row **1514**: Put "SF;Pom" in **SpecialBehaviour** and "No;Xian" in **GotCorn**
68.Row **1525**: Put "Tolerance;Intrusion" in **DyadResponse** and "SF;Piep" in **Context** and "No;Kom;1" in **GotCorn**
69.Row **1536**: Put "AP;Sey;RT;Sirk" in **SpecialBehaviour**
70.Row **1537**: Put "SF;Sey" in **SpecialBehaviour** and "No;Sirk" in **GotCorn**
71.Row **1550**: Put "No;Both" in **GotCorn**
72.Row **1551**: Put "SF;Sey" in **SpecialBehaviour** and "No;Sirk" in **GotCorn**
73.Row **1569**: Put "No;Sho" in **GotCorn**
74.Row **1617**: Put "SF;Both" in **SpecialBehaviour**
75.Row **1639**: Put "SF;Both" in **SpecialBehaviour**
76.Row **1640**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;2" in **GotCorn**
77.Row **1642**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;2" in **GotCorn**
78.Row **1741**: Put "No;Ouli" in **GotCorn**
79.Row **1778**: Put "No;Pom" in **GotCorn**
80.Row **1885**: Delete row
81.Row **1894**: Put "No;Ndaw" in **GotCorn** and "Ghid" in **IntruderID**
82.Row **2031**: Put "No;Piep" in **GotCorn** 
83.Row **2035**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
84.Row **2052**: Put "SF;Sey" in **SpecialBehaviour** and "No;Sirk" in **GotCorn**
85.Row **2089**: Put "No;Piep" in **GotCorn**
86.Row **2090**: Put "No;Piep" in **GotCorn**
87.Row **2123**: Put "Oupa" in **IntruderID** and "No;Both" in **GotCorn**
88.Row **2135**: Put "No;Sho" in **GotCorn**
89.Row **2244**: Put "Scared;Oerw" in **SpecialBehaviour** and "No;Oerw" in **GotCorn**
90.Row **2245**: Put "Oerw" in **IDIdnvidual1**
91.Row **2253**: Put "AP;Sey;RT;Sirk" in **SpecialBehaviour** and "No;Sirk" in **GotCorn**
92.Row **2254**: Put "Sirk" in **IDIndividual1**
93.Row **2313**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn**
94.Row **2316**: Put "Pix" in **IntruderID**
95.Row **2364**: Put "No;Sho" in **GotCorn**
96.Row **2382**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
97.Row **2386**: Put "No;Piep" in **GotCorn** 
98.Row **2436**: Put "No;Piep" in **GotCorn** 
99.Row **2442**: Put "FL;Piep"
100. Row **2466**: Put "No;Ginq" in **GotCorn**
101. Row **2479**: Put "SF;Piep" in **SpecialBehaviour** and "No;Xia;1" in **GotCorn**
102. Row **2484**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
103. Row **2490**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep" in **GotCorn**
104. Row **2515**: Put "SF;Sey" in **SpecialBehaviour** and "No;Sirk" in **GotCorn**
105. Row **2548**: Put "FL;Oerw" in **SpecialBehaviour**
106. Row **2549**: Put "SF;Sey" in **SpecialBehaviour** and "No;Sirk" in **GotCorn**
107. Row **2559**: Put "SF;Sirk" in **SpecialBehaviour** and "No;Sey" in **GotCorn**
108. Row **2601**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;1" in **GotCorn** and "SFTolerance;Piep" in **Context**
109. Row **2609**: Put "SF;Xia" in **SpecialBehaviour** and "No;Piep;2" in **GotCorn** and "SFTolerance;Piep" in **Context**
110. Row **2621**: Put "Oup" in **IntruderID**
111. Row **2670**: Put "No;Piep" in **GotCorn**
112. Row **2675**: Put "SF;Piep" in **SpecialBehaviour** and **No;Xia;1** in **GotCorn**
113. Row **2738**: Put "SF;Xia" in **SpecialBehaviour** and **No;Piep** in **GotCorn**
114. Row **2741**: Put "No;Piep" in **GotCorn**
115. Row **2748**: Put "CheckBox;Both" in **SpecialBehaviour**
116. Make sure the code is safe for multiple run especially for the deleted rows


117. Change the remarks into "Treated" for the following rows: **28, 158, 225, 425, 483, 491, 517, 531, 541, 635, 770, 794, 795, 811, 812, 813, 899, 910, 916, 917, 918, 927, 963, 965, 967, 968, 969, 971, 977, 978, 1010, 1013, 1033, 1038, 1039, 1040, 1041, 1044, 1057, 1072, 1073, 1079, 1080, 1087, 1116, 1120, 1134, 1204, 1207, 1245, 1265, 1289, 1335, 1337, 1339, 1343, 1350, 1352, 1353, 1354, 1357, 1438, 1459, 1511, 1514, 1525, 1536, 1537, 1550, 1551, 1569, 1617, 1639, 1640, 1642, 1741, 1777, 1778, 1885, 1894, 2031, 2035, 2052, 2089, 2090, 2123, 2135, 2244, 2245, 2253, 2254, 2313, 2316, 2341, 2346, 2364, 2382, 2386, 2436, 2442, 2466, 2471, 2479, 2484, 2490, 2515, 2548, 2549, 2559, 2601, 2609, 2621, 2626, 2670, 2675, 2722, 2738, 2741, 2748**
118. Display the lines where changes were made for manual check

```{r Remarks - ate cleaning, echo=FALSE}


```





corn	146
after	84
approach	74
stole	69
left	68

ate	28



audience	44
open 45
intrude	27
numerical_value_m	68
trial	8
steal	8
work	2
scare	2
foraging	0, 1402
alarm	0




$approach
 [1]   49   88   89  159  327  350  522  789  794  804  851  869  873  894  924  962  988 1024 1082 1137 1260 1262 1270 1382 1406 1408 1410 1432 1471 1473 1522 1523 1526 1527
[35] 1577 1585 1619 1635 1636 1643 1700 1703 1756 1796 1880 1884 1901 1908 1910 1958 1990 2102 2141 2147 2148 2150 2178 2179 2205 2219 2237 2267 2284 2334 2383 2385 2446 2472
[69] 2600 2690 2695 2717 2726 2764





$stole
 [1]  138  139  158  427  493  519  543  613  637  796  797  800  869  903  914  921  926  931  967  969  970  973  975  981  982 1012 1014 1017 1042 1043 1044 1045 1048 1083
[35] 1084 1091 1118 1120 1220 1232 1234 1269 1339 1341 1343 1347 1354 1356 1357 1358 1442 1518 1555 1595 1623 1645 1646 1648 1701 1703 1900 2042 2389 2467 2486 2491 2497 2608
[69] 2616



$corn
  [1]   12   28  158  225  427  485  493  519  533  543  613  618  637  772  796  797  800  815  816  817  869  903  914  920  921  922  926  931  967  969  971  972  973  975
 [35]  981  982 1011 1012 1014 1017 1037 1042 1043 1044 1045 1048 1061 1076 1077 1083 1084 1091 1113 1118 1120 1124 1138 1176 1208 1211 1249 1269 1271 1293 1338 1339 1341 1343
 [69] 1347 1354 1356 1357 1358 1361 1432 1442 1463 1515 1518 1522 1529 1540 1541 1554 1555 1573 1595 1623 1645 1646 1648 1701 1703 1747 1756 1783 1784 1796 1891 1900 2038 2039
[103] 2041 2042 2059 2096 2097 2130 2142 2251 2252 2260 2261 2271 2320 2323 2348 2353 2371 2385 2389 2393 2398 2443 2449 2473 2478 2486 2491 2497 2522 2555 2556 2566 2592 2608
[137] 2616 2628 2633 2677 2682 2688 2729 2745 2748 2755

$ate
 [1]   12   70  406  920  922 1061 1113 1293 1361 1380 1454 1463 1477 1479 1529 1541 1595 1816 1967 2038 2039 2251 2353 2438 2478 2493 2633 2745

$numerical_value_m
 [1]   32   33   34   35   36   37   38   39   40   89  389  392 1090 1178 2040

$code_3_letters
  [1]    3    4    7   12   28   49   52   70   88   89   98  142  158  191  225  247  280  327  350  374  379  380  381  386  387  406  419  427  466  485  488  490  493  519
 [35]  521  522  533  543  600  613  618  660  768  770  771  772  774  783  789  794  796  797  798  800  804  815  816  817  851  860  869  873  886  894  903  914  916  920
 [69]  921  922  923  926  928  933  935  936  938  943  945  946  947  956  962  967  969  970  971  972  973  975  977  978  981  982  991  992  995 1009 1011 1012 1014 1017
[103] 1037 1044 1045 1048 1061 1069 1071 1073 1076 1077 1078 1080 1082 1083 1084 1090 1091 1113 1114 1118 1120 1127 1137 1138 1176 1180 1194 1208 1211 1220 1232 1234 1239 1240
[137] 1244 1246 1249 1257 1258 1259 1260 1262 1268 1269 1270 1271 1273 1274 1275 1277 1290 1293 1318 1330 1331 1338 1339 1341 1343 1347 1354 1356 1357 1358 1361 1370 1376 1378
[171] 1380 1382 1393 1396 1406 1407 1408 1410 1411 1420 1426 1427 1432 1442 1443 1452 1453 1454 1458 1463 1466 1471 1472 1473 1477 1479 1481 1486 1487 1492 1499 1501 1503 1504
[205] 1515 1522 1523 1526 1527 1529 1533 1540 1541 1545 1547 1550 1553 1554 1555 1560 1561 1563 1568 1573 1575 1577 1579 1580 1581 1585 1587 1595 1619 1623 1624 1633 1635 1636
[239] 1637 1639 1643 1645 1646 1648 1651 1668 1670 1676 1681 1683 1703 1705 1710 1713 1721 1747 1756 1775 1783 1784 1785 1788 1792 1794 1795 1796 1802 1803 1807 1808 1815 1816
[273] 1828 1837 1851 1858 1859 1860 1861 1866 1867 1870 1872 1874 1877 1880 1884 1891 1892 1894 1899 1901 1902 1903 1904 1905 1906 1908 1910 1914 1915 1919 1937 1958 1962 1972
[307] 1985 1990 1992 1995 2023 2035 2038 2039 2040 2041 2042 2054 2059 2060 2063 2067 2068 2096 2097 2099 2102 2105 2108 2109 2123 2128 2130 2136 2138 2141 2142 2146 2147 2148
[341] 2149 2150 2151 2163 2167 2178 2179 2193 2194 2195 2202 2205 2206 2209 2219 2221 2237 2251 2252 2256 2259 2260 2261 2262 2267 2271 2273 2284 2291 2313 2320 2323 2324 2334
[375] 2344 2348 2349 2352 2353 2366 2371 2373 2377 2383 2385 2389 2393 2398 2418 2428 2430 2434 2438 2443 2446 2449 2465 2467 2472 2473 2478 2481 2482 2483 2486 2491 2492 2493
[409] 2497 2522 2547 2548 2549 2555 2556 2566 2579 2592 2600 2603 2604 2608 2611 2616 2628 2632 2633 2641 2644 2676 2677 2682 2688 2690 2693 2694 2695 2696 2700 2703 2708 2709
[443] 2717 2726 2729 2736 2745 2746 2748 2755 2764 2767 2770 2787 2793 2795

$code_4_letters
  [1]    3    4    7   12   28   49   52   70   88   89   95  136  138  139  142  158  159  191  223  225  280  389  392  406  419  427  485  490  493  519  521  522  533  543
 [35]  600  613  618  637  660  693  768  772  789  794  796  797  798  800  804  815  816  817  819  851  869  873  894  903  914  920  921  922  924  926  928  931  933  936
 [69]  938  943  945  947  956  962  967  969  970  971  972  973  975  977  978  981  982  988  991  992  995 1008 1009 1011 1012 1014 1017 1019 1024 1032 1037 1042 1043 1044
[103] 1045 1048 1061 1069 1071 1076 1077 1080 1082 1083 1084 1090 1091 1113 1114 1118 1120 1124 1127 1137 1138 1172 1174 1176 1179 1180 1194 1208 1211 1220 1232 1234 1239 1240
[137] 1244 1246 1249 1257 1258 1259 1260 1262 1268 1269 1270 1271 1272 1273 1274 1293 1306 1330 1331 1337 1338 1339 1341 1343 1347 1349 1354 1356 1357 1358 1361 1370 1380 1382
[171] 1385 1393 1406 1407 1408 1410 1414 1420 1421 1426 1427 1429 1432 1442 1443 1452 1453 1454 1458 1463 1466 1471 1473 1477 1479 1487 1492 1515 1518 1519 1522 1523 1526 1527
[205] 1529 1540 1541 1545 1547 1550 1553 1554 1555 1563 1568 1573 1575 1577 1579 1580 1585 1587 1595 1619 1623 1624 1633 1635 1636 1637 1639 1643 1645 1646 1648 1651 1661 1668
[239] 1681 1686 1692 1700 1701 1703 1705 1706 1715 1720 1721 1734 1747 1756 1775 1783 1784 1785 1788 1792 1794 1795 1796 1802 1803 1807 1808 1815 1816 1828 1837 1851 1860 1861
[273] 1866 1867 1870 1874 1877 1880 1882 1891 1894 1899 1900 1901 1902 1903 1904 1905 1906 1908 1910 1914 1921 1937 1956 1958 1960 1962 1967 1972 1985 1990 1992 1995 2035 2038
[307] 2039 2040 2041 2042 2054 2059 2060 2063 2067 2096 2097 2105 2108 2109 2123 2128 2130 2136 2141 2142 2146 2148 2149 2150 2151 2160 2163 2167 2178 2179 2193 2195 2202 2205
[341] 2206 2209 2217 2218 2221 2222 2224 2225 2237 2243 2251 2252 2256 2259 2260 2261 2262 2267 2271 2284 2291 2297 2313 2320 2323 2324 2332 2334 2344 2348 2349 2352 2353 2355
[375] 2366 2371 2377 2383 2385 2389 2393 2398 2420 2428 2430 2431 2434 2438 2443 2446 2449 2465 2467 2472 2473 2478 2481 2482 2486 2491 2492 2493 2497 2522 2529 2530 2547 2548
[409] 2549 2555 2556 2566 2579 2592 2600 2603 2604 2608 2611 2616 2628 2632 2633 2644 2676 2677 2682 2688 2690 2693 2694 2695 2696 2700 2703 2708 2709 2717 2726 2729 2736 2745
[443] 2746 2748 2755 2764 2767 2770 2773 2787 2795

$audience
 [1]   72   73   74   75   76   77   78   79   80   81   82   83   84   85  103  104  105  106  107  108  109  110  789  962 1883 2774 2775 2778 2779 2780 2781 2782 2783 2784
[35] 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794

$present
[1] 2770

$sec
 [1]   49  159  851 1082 1277 1545 1575 1595 1692 1700 1706 1807 1815 1866 1870 1874 1882 2040 2060 2063 2067 2099 2128 2149 2163 2167 2313 2349 2398 2446 2472 2492 2549 2746

$before
 [1]  151  176  178  179  182  388  391  418  466  646  660  733  755  758  787  804  848  899  932  945 1011 1054 1080 1172 1331 1361 1904 1905 1906 2348 2353

$after
 [1]   12   49  158  159  163  172  238  280  336  350  371  509  618  653  700  789  794  804  851  860  873  953  978  988  991 1012 1019 1024 1037 1137 1277 1361 1382 1393
[35] 1427 1432 1522 1540 1545 1547 1575 1577 1587 1595 1624 1692 1700 1706 1807 1815 1827 1866 1870 1874 1877 1882 1990 2060 2063 2067 2099 2128 2141 2149 2163 2167 2179 2217
[69] 2252 2261 2349 2398 2434 2472 2478 2483 2499 2549 2555 2579 2726 2729 2746 2773

$left
 [1]  789  794  804  873  933  988 1024 1137 1262 1293 1382 1393 1420 1427 1432 1545 1547 1563 1575 1577 1587 1624 1636 1651 1785 1794 1795 1807 1816 1828 1867 1891 1906 1985
[35] 1990 2035 2041 2060 2063 2067 2128 2150 2151 2179 2217 2218 2224 2252 2261 2262 2267 2334 2366 2385 2431 2449 2473 2481 2482 2529 2530 2548 2549 2579 2676 2717 2726 2746
[69] 2773







* I will now create a variable called **NoRemarks** that will put 1 where there is a remark and 0 where there is nothing




```{r Creation of NoRemarks, echo=FALSE}

# Check if the 'NoRemarks' column already exists
if (!"NoRemarks" %in% names(Bex)) {
  # Creation of a New dichotomous variable "No Remarks"
  Bex$NoRemarks <- ifelse(Bex$Remarks == "No Remarks", 1, 0)

  # Count the number of 1's (No Remarks) and 0's (Remarks) in the "NoRemarks" column
  no_remarks_1_count <- sum(Bex$NoRemarks == 1)
  no_remarks_0_count <- sum(Bex$NoRemarks == 0)

  cat("Number of 'No Remarks' (1's) in the 'NoRemarks' column:", no_remarks_1_count, "\n")
  cat("Number of 'Remarks' (0's) in the 'NoRemarks' column:", no_remarks_0_count, "\n")
} else {
  cat("The 'NoRemarks' column already exists. No changes made.\n")
}


```

#### 2.3.2 Cleaning "Intruder ID" - (2737 NA's)
* **Intruder ID** is a variable that contains the **name of the individuals that made and intrusion during a trial**.
* If more than one individual intruded, his name may be in the comments, which I will check when treating the data from this column
* Because nothing was entered when there was no intrusion, I will replace every NA's by **No Intrusion**
* Also, I will use a function to create a new dichotomic variable called **Intrusion**. Every time there is a value in IntruderID, it should display 1 (Yes), if not a 0 (No intrusion)


```{r IntruderID NA, echo=FALSE}

# Check if the 'Intrusion' column already exists
if (!"Intrusion" %in% names(Bex)) {
  # Replace NA's with "No Intrusion" in the "Intruder ID" column
  Bex$IntruderID[is.na(Bex$IntruderID)] <- "No Intrusion"

# Create a new dichotomic variable called "Intrusion"
Bex$Intrusion <- ifelse(Bex$IntruderID == "No Intrusion", 0, 1)

 # Check how many times "No Intrusion" appears in the "Intruder ID" column after replacement
  no_intrusion_count <- sum(Bex$IntruderID == "No Intrusion")
  cat("Number of 'No Intrusion' in the 'Intruder ID' column after replacement:", no_intrusion_count, "\n")
} else {
  cat("The 'Intrusion' column already exists. No changes made.\n")
}
```
* We previously had 2737 NA's in IntruderID while now we have the same amount of occurrences of IntruderID which shis that the transformation went as intended

#### 2.3.3 Cleaning "IdIndividual1" - (2143 NA's)

* IdIndividual1 is meant to report the name of the individual that did a behavior such as not approach, show aggression or loose interest during a trial
* I will now replace every NA in this column by **No individual**
* And **if there are more than one value per cell**, report it in a new column called ">1 Response"
  
  
```{r IdIndividual1 NA, echo=FALSE}
# Check if the "MultipleResponses" column already exists
if (!"MultipleResponses" %in% names(Bex)) {
  # Replace NA in IDindividual1 by "No individual"

# Check for multiple responses
  Bex$MultipleResponses <- ifelse(
    Bex$IDIndividual1 != "No individual" & grepl("; ", Bex$DyadResponse),
    ">1 Response",
    ifelse(Bex$IDIndividual1 != "No individual" & grepl(", ", Bex$DyadResponse), ">1 Response", "Single Response")
  )

  View(Bex)
} else {
  cat("The 'MultipleResponses' column already exists. No changes made.\n")
}

```
  

#### 2.6 Cleaning "Audience"
* Audience is made to report every name of individuals around our dyad during a given trial
* I will replace every NA by **No audience** as no entry means the absence of other individuals around
* I will also create a new variable called "Amount audience" that will have to tell me how many individuals are found in the column Audience 

```{r Audience NA, echo=FALSE}
#Creating amount of audience
Bex$AmountAudience <- ifelse(is.na(Bex$Audience), 0, lengths(strsplit(Bex$Audience, "; ")))

#Changing NA's in No audience
Bex$Audience[is.na(Bex$Audience)] <- "No audience"

```


#### 2.7 Cleaning "OtherResponse"
```{r OtherResposne NA, echo=FALSE}
# Replace NA in OtherResponse by "No Response"
Bex$OtherResponse[is.na(Bex$OtherResponse)] <- "No Response"

```


#### 2.8 Cleaning of "Time"
* Since the reading of the data is more complicated without the time, which was usefull to know which trial was before or after, I changed the code made for Bex and added **Time** in the dataframe. Since I will need it for the cleaning of Dyaddistance, I will treat it now

```{r Time, include=FALSE}

# Assuming Bex is your dataframe
# Convert 'Time' to POSIXct format
Bex$Time <- as.POSIXct(Bex$Time, format = "%Y-%m-%d %H:%M:%S")

# Extract only the time from 'Time' and assign it update Time'
Bex$Time <- format(Bex$Time, "%H:%M:%S")


```


#### 2.9 Cleaning DyadDistance
* Before looking at the NA's of Dyaddistance I will remove the "m" that is in front of every number to      have a numerical variable
* Then I will look at the location of the NA's in the data to treat them case by case.


```{r DyadDistance NA, echo=FALSE}

# Check if the dataset has the necessary columns before proceeding 
if ("DyadDistance" %in% names(Bex)) {

  # Check if modifications are needed (avoiding unnecessary changes on multiple runs)
  if (!is.numeric(Bex$DyadDistance)) {
    
    # Remove "m" from DyadDistance and convert to numeric
    Bex$DyadDistance <- as.numeric(gsub("m", "", Bex$DyadDistance), errors = "coerce")
    
    # Identify NA values in DyadDistance
    NA_DyadDistance <- Bex[is.na(Bex$DyadDistance), ]
    
    # View the locations of NA values
    View(NA_DyadDistance)
    
    # Count the number of missing values in the DyadDistance column
    dyad_distance_missing_data <- Bex[is.na(Bex$DyadDistance), ]
    
    # Print the result
    cat("Number of NA values in DyadDistance column (using second approach):", nrow(dyad_distance_missing_data), "\n")
    
    # Find row indices with NA values in DyadDistance
    dyad_distance_na_row <- which(is.na(Bex$DyadDistance))
    
    # Print the row indices
    cat("Rows with NA values in DyadDistance column:", paste(dyad_distance_na_row, collapse = ", "), "\n")

  } else {
    cat("No modifications needed for DyadDistance. It already appears to be in the desired format.\n")
  }

} else {
  # Display a message or take alternative actions if columns are missing
  cat("Error: Required columns not found in the dataset.\n")
}

```



* We have 69 missing values in  DyadDistance. I will look at each row in it's context as the actual distance of the box was always dependent of the previous trials. I will start with the bigger number as for now the oldest trial is at the last row while the closest one is in row 1.



  - If **tolerance** was achieved **twice in a row**     =   <1m
  - If **aggression** (male agress female or female agress male), not approaching,or **loosing     interest** occured                                   =   >1m
  - If **distracted** or **intrusion** occured           =    same distance
  
  1. **24** - In trial23 (0m) there was aggression then at trial24 (1m) there was tolerance. The 24th trial is supposed to be at **1m**
  2. **27** - In trial25 (1m) there was not approaching then at trial26 (2m) there was tolerance.The 25th trial is supposed to be at **2m**
  3. **95** - In trial93 (2m ) there was male agress female then at trial 94 (3m) there was not approaching. The 95th trial is supposed to be at **4m**
  4. **492** - In trial490 (0m) there was tolerance then at trial491 (0m) there was tolerance. The 492nd trial is supposed to be at **0m**
  5. **744** - In trial742 (3m) there was aggression then at trial743 (4m) there was tolerance. The 744th trial is supposed to be at **4m**    
  6. **971** - In trial969 (0m) there was tolerance then at trial970 (0m) there was tolerance. The 971st trial is supposed to be at **0m**
  7. **1113** - In trial1111 (2m) there was tolerance then at trial1112 (0m) there was tolerance. The 1113th trial is supposed to be at **0m**
  8. **1130** - In trial1128 there was another dyad so we can not use this cell. Then at trial1129 (3m) there was not approaching. Nevertheless, we don't have any DyadResponse, i will thus **delete this row** 
  9. **1164** - In trial1162 (3m) there was not approaching then at trial1163 (3m) there was not approaching. The 1164th trial is supposed to be at **4m**
  10. **1261** - The two
  preivous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  11. **1341** - In trial1339 (0m) there was tolerance then at trial1340 (0m) there was tolerance. The 1341st trial is supposed to be at **0m**
  12. **1396** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  13. **1491** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  14. **1583** - In trial1581 (2m) there was not approaching and intrusion then at trial1582 (2m) there was not approaching. The 1583rd trial is supposed to be at **3m**
  15. **1683** - One trial only was made with tolerance (2m) but since there are no DyadResponse I will **delete this row**
  16. **1693** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  17. **1717** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  18. **1718** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  19. **1719** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  20. **1724** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  21. **1725** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  22. **1739** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  23. **1755** - since there are no DyadResponse I will **delete this row**
  24. **1756** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  25. **1757** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  26. **1764** - Since there are no DyadResponse I will **delete this row**
  27. **1779** - It seems like it was the first trial of the Dyad Pom Xian, if so, the distance has to be **5m**
  28. **1782** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  29. **1792** - Trial1791 was intrusion (4m) so this trial should be at **4m**
  30. **1799** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  31. **1800** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  32. **1840** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  33. **1841** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  34. **1868** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  35. **1869** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  36. **1888** - he two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  37. **1891** - Since there are no DyadResponse I will **delete this row**
  38. **1892** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  39. **1896** - Since there are no DyadResponse I will **delete this row**
  40. **1911** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  41. **1912** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  42. **1915** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  43. **1918** - In trial1916 (4m) there was tolerance then at trial1917 (4m) there was not loosing interest The 1918th trial is supposed to be at **4m**
  44. **1919** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  45. **1952** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  46. **1953** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  47. **1958** - In trial1956 (2m) there was tolerance then at trial1957 (2m) there was distracted. The 1958th trial is supposed to be at **2m**
  48. **1980** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  49. **1981** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  50. **1984** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  51. **1986** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  52. **1996** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  53. **2000** - In trial1997 and 1999 (5m) there was tolerance then at trial1999 (5m) there was intrusion. The 2000th trial is supposed to be at **4m**
  54. **2009** - Since there are no DyadResponse I will **delete this row**
  55. **2054** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  56. **2104** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  57. **2105** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  58. **2191** - In trial2189 (1m) there was not approaching then at trial2190 (2m) there was not approaching. The 2191st trial is supposed to be at **3m**
  59. **2233** - In trial2231 (3m) there was not approaching then at trial2232 (4m) there was not approaching. The 2233rd trial is supposed to be at **5m**
  60. **2234** - The trial did not happen because they where not at the right distance. I will thus **delete this row**
  61. **2287** - Since there are no DyadResponse I will **delete this row**
  62. **2437** - Since there are no DyadResponse I will **delete this row**
  63. **2569** - In trial2567 (1m) there was tolerance then at trial2568 (1m) there was tolerance. The 2569th trial is supposed to be at (0m)
  64. **2579** - In trial2577 (1m) there was tolerance then at trial2578 (0m) there was not approaching. The 2579th trial is supposed to be at **1m**
  65. **2580** - The two previous trials were made with another Dyad. Also DyadResponse is not available. I will thus **delete this row**
  66. **2643** - Since there are no DyadResponse I will **delete this row**
  67. **2676** - In trial2674 (1m) there was tolerance then at trial2675 (0m) there was tolerance. The 2676th trial is supposed to be at **0m**
  68. **2709** - In trial2707 (2m) there was tolerance then at trial2708 (2m) there was tolerance. The 2709th trial is supposed to be at **1m**
  69. **2729** - In trial2727 (3m) there wastolerance then at trial2728 (2m) there was tolerance. The 2729th trial is supposed to be at **2m**


* Now that I have looked at each missing line and saw which ones to keep, I decided to create a new variable called **Distance**. I will also to create a new variable called **No trial**.
* For the variable **Distance** I will replace each row where there was missing data with a value and I will delete the ones where no values could be assigned. This will allow me to have no missing data and find a number to each trial that has been done
 
```{r Distance2, echo=FALSE}

# Check if the dataset has the necessary columns before proceeding 
if ("DyadDistance" %in% names(Bex)) {

  # Check if the modification has already been applied
  if (!all(c("Dyadistance", "Distance") %in% names(Bex))) {
    
    # Define replacement values
    replacement_values <- c(
      `24` = 1, `27` = 2, `95` = 4, `492` = 0, `744` = 4, `971` = 0, `1113` = 0, `1164` = 4,
      `1341` = 0, `1583` = 3, `1779` = 5, `1792` = 4, `1840` = 0, `1868` = 0, `1918` = 4,
      `2000` = 4, `2191` = 3, `2233` = 5, `2569` = 0, `2579` = 1, `2676` = 0, `2709` = 1, `2729` = 2
    )}
}
    
   # Check if the "Distance" column already exists
    if (!"Distance" %in% names(Bex)) {

      # Check if there are duplicate column names and handle them
      if (any(duplicated(names(Bex)))) {
        duplicate_names <- names(Bex)[duplicated(names(Bex))]
        cat("Duplicate column names found: ", paste(duplicate_names, collapse = ", "), "\n")
        for (col_name in duplicate_names) {
          new_col_name <- paste0(col_name, "_duplicate")
          Bex <- Bex %>% rename(!!new_col_name := !!col_name)
          cat("Renamed column '", col_name, "' to '", new_col_name, "'\n")
        }
      }

      # Applying rules to update DyadDistance
      Bex <- Bex %>%
        mutate(
          Dyadistance = ifelse(row_number() %in% names(replacement_values), replacement_values[as.character(row_number())], DyadDistance)
        )

      # Create a new column Distance with values from DyadDistance
      Bex <- Bex %>% mutate(Distance = Dyadistance)

      # Count NA's in Distance
      na_count <- sum(is.na(Bex$Distance))
      print(paste("Number of NA's in Distance: ", na_count))

      # Remove rows with NA in Distance after replacing values
      Bex <- Bex %>% filter(!is.na(Distance))

      # Count NA's in Distance after removing NA's
      na_count <- sum(is.na(Bex$Distance))
      print(paste("Number of NA's in Distance after removing NA's: ", na_count))
      
} else {
  # Display a message or take alternative actions if columns are missing
  cat("Error: Required columns not found in the dataset.\n")
}

``` 
*In this modification, I added a check to see if the columns Dyadistance and Distance already exist in your dataframe (Bex). If they do, it prints a message saying that the modification has already been applied, and no changes are made. If they don't exist, it proceeds with the modifications. This way, running the code multiple times won't cause redundant changes.
  
* **23 values** were inserted in **Distance** to replace the NA's where the distance could be found by looking at the previous rows. The **46 remaining NA's** were then **removed** from Distance **leaving 0 NA in Distance**

* Now I would like to create a dichotomic variable called **No trial** that will use the rows that I deleted in Distance. I would like this column to put 1 for every trial that was deleted from Distance. I will later on look again at this column. 
* I decided to this since I remebered that the lines where we could not assign any distance happened when the monekys where
 1. The dyad was not close enough to do the experiment 
 2. We had another dyad at proximity that we were more interested or that was easier to test
I will use this variable to look at the cases where this happen. at term I will not use this variable in my analysis

```{r No Trial, include=FALSE}

# Identify rows to delete based on the rules
rows_to_delete <- c(24, 27, 95, 492, 744, 971, 1113, 1130, 1164, 1261, 1341, 1396, 1491, 1583, 1683, 1693, 1717, 1718, 1719,
                    1724, 1725, 1739, 1755, 1756, 1757, 1764, 1779, 1782, 1792, 1799, 1800, 1840, 1841, 1868, 1869, 1888, 1891,
                    1892, 1896, 1911, 1912, 1915, 1919, 1952, 1953, 1958, 1980, 1981, 1984, 1986, 1996, 2000, 2009, 2054, 2104,
                    2105, 2191, 2233, 2234, 2287, 2437, 2569, 2579, 2580, 2643, 2676, 2709, 2729)

# Create NoTrial variable
Bex$NoTrial <- ifelse(seq_along(Bex$Distance) %in% rows_to_delete, 1, 0)

```




#### 2.10 Cleaning Female and Male ID

* Before cleaning here are all the dyads that were present during the experiment. This will help us find the missing names when only one ID is missing (either male or female):
  a. Sirk & Sey - BD
  b. Ouli & Xin - BD
  c. Piep & Xia - BD
  d. Oerw & Nge - BD
  e. Oort & Kom - BD
  
  f. Ginq & Sho - AK
  g. Ndaw & Buk - Ak
  
  h. Xian & Pom - AK
  i. Guat & Pom - Ak
* First I have to check where are the NA's in both FemaleID and Male ID by looking at the rows where data is missing. Since every trial was made with a Dyad, trating these two columns together makes more sense. 


```{r FemaleMaleID NA, echo=FALSE}

# Replace all NA values in MaleID and FemaleID with NA
Bex <- Bex %>%
  mutate(
    MaleID = ifelse(is.na(MaleID), NA, MaleID),
    FemaleID = ifelse(is.na(FemaleID), NA, FemaleID)
  )

# Checking for amount of  missing values in FemaleID and MaleID

# Missing values in FemaleID
female_missing_rows <- which(is.na(Bex$FemaleID))
View(Bex[female_missing_rows, ])
cat("Number of missing values in FemaleID: ", sum(is.na(Bex$FemaleID)), "\n")

# Missing values in MaleID
male_missing_rows <- which(is.na(Bex$MaleID))
View(Bex[male_missing_rows, ])
cat("Number of missing values in MaleID: ", sum(is.na(Bex$MaleID)), "\n")

   
# Checking for location of missing values in FemaleID and MaleID

# Missing values in FemaleID
female_missing_rows <- which(is.na(Bex$FemaleID))
cat("Row numbers with missing values in FemaleID: ", female_missing_rows, "\n")
cat("Number of missing values in FemaleID: ", length(female_missing_rows), "\n")

# Missing values in MaleID
male_missing_rows <- which(is.na(Bex$MaleID))
cat("Row numbers with missing values in MaleID: ", male_missing_rows, "\n")
cat("Number of missing values in MaleID: ", length(male_missing_rows), "\n")



# Check where we have Na in both Female and Male ID  and in whcih rows
# Row numbers with missing values in both FemaleID and MaleID
both_missing_rows <- which(is.na(Bex$FemaleID) & is.na(Bex$MaleID))

# Count of rows with missing values in both FemaleID and MaleID
both_missing_count <- length(both_missing_rows)

cat("Number of rows with missing values in both FemaleID and MaleID: ", both_missing_count, "\n")
cat("Row numbers with missing values in both FemaleID and MaleID: ", toString(both_missing_rows), "\n")


# Rows with missing values in FemaleID but not in MaleID
only_female_missing_rows <- setdiff(female_missing_rows, both_missing_rows)

# Count of rows with missing values only in FemaleID
only_female_missing_count <- length(only_female_missing_rows)

cat("Number of missing values in FemaleID not in MaleID: ", only_female_missing_count, "\n")
cat("Row numbers with missing values in FemaleID not in MaleID: ", toString(only_female_missing_rows), "\n")



```
    
    
* **FemaleID** has **44 NA's** while they are **18 NA's** in **Male ID**
* In these missing data, we have **18 NA's** that are in common between FemaleID and MaleID which represents the totality of the missing values in MaleID
* Looking at he NA's in Male ID, we see that all the missing data except one entry, comes from the 19th of april 2023 in Noha. We can also see that trials had bee made in the same day, and looking at the time of the experiment, the previous trails made and the audience we can see that these NA's in female and male ID are in the rows 1699 to 1716 and should have been made with **Xian** for the female ID and **Pom** for the **MaleID**. I will thus replace these values using a condtion. These NA's in Noha (Trial 1699 to 1716) are the only NA's that MaleID has and are the only NA's of female ID in Noha. I will thus replace every NA of **MaleID NA in Noha** with **Pom** and every **Female ID NA in Noha** with **Xian**


```{r Male ID NA, echo=FALSE}
library(dplyr)

# Update the dataset
Bex <- Bex %>%
  mutate(
    MaleID = ifelse(Group == "Noha" & is.na(MaleID), "Pom", MaleID),
    FemaleID = ifelse(Group == "Noha" & is.na(FemaleID), "Xian", FemaleID)
  )

```


* In order to clean FemaleID, I will use the data from the now complete MaleID. I will use conditions stating that depending which name is found in MaleID when there is an NA in FemaleID, a certain name will have to replace the NA in female ID:

  If there is NA in female ID, we will eplace the value with 
    - Sirk if MaleID is Sey
    - Ouli if MaleID  is Xin
    - Piep if MaleID  is  Xia 
    - Oerw if MaleID  is  Nge 
    - Oort if MaleID  is  Kom 
    - Ginq if MaleID  is  Sho 
    - Ndaw if MaleID  is  Buk 

```{r FemaleID, include=FALSE}

library(dplyr)

# Assuming Bex is your data frame
Bex <- Bex %>%
  mutate(
    FemaleID = case_when(
      is.na(FemaleID) & MaleID == "Sey" ~ "Sirk",
      is.na(FemaleID) & MaleID == "Xin" ~ "Ouli",
      is.na(FemaleID) & MaleID == "Xia" ~ "Piep",
      is.na(FemaleID) & MaleID == "Nge" ~ "Oerw",
      is.na(FemaleID) & MaleID == "Kom" ~ "Oort",
      is.na(FemaleID) & MaleID == "Sho" ~ "Ginq",
      is.na(FemaleID) & MaleID == "Buk" ~ "Ndaw",
      TRUE ~ FemaleID  # Keep the existing value if none of the conditions are met
    )
  )


# Count NA values in MaleID
na_count_male <- sum(is.na(Bex$MaleID))
cat("Number of NA values in MaleID: ", na_count_male, "\n")

# Count NA values in FemaleID
na_count_female <- sum(is.na(Bex$FemaleID))
cat("Number of NA values in FemaleID: ", na_count_female, "\n")

```


* After the use of the conditions in FemaleID I could see the the changes where successufly done and that 0 NA's are remaing in both FemaleID and MaleID



*I HAVE TO CHECK IF THE ROW IS STILL HERE AND WHAT TO DO ABOUT IT The row 1915 explains to us that the experiment was not possible because we had a BGE and could not do the experiment. I would like to count this line by putting a 1 in No trial but I don't want to keep this line in Male or Female ID. I will have to see how I treat this line since no trial was made, meaning I cannot put any value in DyadDistance, ID (Male and Female) nor DyadResponse


* Row numbers of Female and Male ID to check if every line was correctly changed
* Female ID: 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1886 1887 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 

* Male ID: 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 
Number of missing values in MaleID:  18 






#### 2.12 Final check: remaing NA's in Bex?

```{r Check if Remaing NA, echo=FALSE}
# Find columns with NA values
columns_with_na <- colnames(Bex)[colSums(is.na(Bex)) > 0]

# Print the columns with NA values
cat("Columns with NA values:", toString(columns_with_na), "\n")

# Print the number of NA values in each column
for (col in columns_with_na) {
  cat("Number of NA values in", col, ":", sum(is.na(Bex[[col]])), "\n")
}


```
    
    
  * The remaining rows with NA's are the row **866** that I will delete since no information at all is available for the DyadResponse. Concerning the row **1211** we can see that the corn was stolen by Oup and Oort. This means that tolerance way achieved and that an agonistic behaviour followed that is maybe not aggression. I will change the DyadResponse of this row to "Other"
  
```{r Cleaning remaining, include=FALSE}
# Delete row where no information is available for DyadResponse
Bex <- Bex[!is.na(Bex$DyadResponse), ]

# Change DyadResponse where the corn was stolen to "Other"
Bex$DyadResponse[Bex$DyadResponse == "Unknown" & Bex$FoodSource == "Stolen corn by Oup & Oort"] <- "Other"

# Find rows with any NA values in the dataset
rows_with_na_numbers <- which(rowSums(is.na(Bex)) > 0)

# Print the number of rows with NA values and their row numbers
cat("Number of rows with NA values in the dataset:", length(rows_with_na_numbers), "\n")
cat("Row numbers with NA values:", toString(rows_with_na_numbers), "\n")

```

* It seems now that no NA's are remaining in the dataset, we can thus continue with the process of cleaning the dataset

### 3. Creating New Variables and modifying the existing ones

#### Making a backup of Bex
* I will now continue making changes, in case they are any problems or comparason to be made I may use this function to look how Bex looked at that point

```{r Backup Bex 1, include=FALSE}
# Create a backup
backup_Bex <- Bex
```


* I will now treat the remaining variables, let's see which ones and why

```{r Bex Names, include=FALSE}


# Get the names of variables in the dataframe
variable_names <- names(Bex)

# Print the list of variable names
cat("Variable names: ", toString(variable_names), "\n")
print(variable_names)


```

#### Time - Creation of Period nad Hour
* Time : I did not plan to use this variable but since I used, I considered looking at the time sections in which we did the expermiment. I will thus look at the time ranges (max and min in the day / latest and earliest time) before separating the day in different sections to have an idea in which part of the day most of the experiments occured. This will not be used in my analysis, but if I wanted to, I could interesting to compare the amount of experimentations made per day and have a line indicating the time of sunrise. 

```{r Time Periods, include=FALSE}
Bex <- Bex %>%
  mutate(Time = as.POSIXct(Time, format = "%H:%M:%S"),
         Period = case_when(
           between(hour(Time), 6, 8) ~ "Early Morning",
           between(hour(Time), 8, 10) ~ "Morning",
           between(hour(Time), 10, 12) ~ "Noon",
           between(hour(Time), 12, 14) ~ "Afternoon",
           between(hour(Time), 14, 17) ~ "End of the Day",
           TRUE ~ NA_character_
         )
  )

```
* The **Minimum Time** in the dataset is **06:03:26*** while the **Maximum Time** is at **16:36:59**
* In my box experiment I have this variable called time that tells me when the experiment was done. I don't think I need this information per se. I was wondering if it could be easy and interesting to see from when to when the time occurs and then separate this time in a few sections like early, monring, morning, miday, afternoon, end of the day
* a.6 to 8 : Early morning
  b.8 to 10: Morning
  c.10 to 12: Noon
  d.12 to 14: Afternoon
  e.14 to 17: End of the day
  
* Last, I want to create a variable called Hour that will take the value in Time and  round it to the hour in which it is ex: from 06:00 to 06:59 -> 6, from 07:00 to 07:59 -> 7 etc...
* This will allow me to see when most of the trials occured with more detail and I will be to see in which hour most of the trial happened. Nevertheless Period will be better for an improved readability
```{r Hour, include=FALSE}

Bex <- Bex %>%
  mutate(Time = as.POSIXct(Time, format = "%H:%M:%S"),  # Convert Time back to POSIXct
         Hour = floor_date(Time, "hour"),  # Create Hour variable
         Hour = format(Hour, "%H:%M:%S"),  # Format Hour for display
         Time = format(Time, "%H:%M:%S"))  # Format Time for display


```

#### Date - Creation of Month and Day
*  i want to Create a variable called month to see the month of the experiment and day so I know which day of the experiment it was (1st, 10th, 1000th..)
```{r Month and Day, include=FALSE}

# Assuming 'Date' is the name of your variable
Bex <- Bex %>%
  arrange(Date) %>%  # Arrange data in ascending order of Date
  mutate(
    Day = as.numeric(difftime(Date, min(Date), units = "days")) + 1,  # Assign a unique day number
    Month = format(Date, "%Y-%m")  # Include both year and month in Month variable
  )

```


#### Group - Ok
#### Male and Female ID - Creation of Dyad, Trial and Session

* I will use Female and Male ID to create different variables
  1. While checking if there are still any mistakes  in **FemaleID and MaleID** using **unique**, I saw that some of the names are in the wrong rows. I want the **3 letter male codes** whether they are in the column FemaleID or MaleID to be in the **new column Male** while I want the **4 letter female codes** whether they are in FemaleID or MaleID to be in the **new column Female** before checking again with unique that the transformation worked. I will use mutate
```{r Female Male ID Check, echo=FALSE}
#Unique outputs for FemaleID
unique_female_ids <- unique(Bex$FemaleID)
cat("Unique Female IDs:", unique_female_ids, "\n")

# Count the occurrences of each name before the transformation
table(Bex$FemaleID)

# Unique outputs for MaleID
unique_male_ids <- unique(Bex$MaleID)
cat("Unique Male IDs:", unique_male_ids, "\n")

# Count the occurrences of each name before the transformation
table(Bex$MaleID)


before_summary <- table(Bex$FemaleID, Bex$MaleID)
kable(print(before_summary))

```
1. Create a variable called Male that in each row will take the name of the **3 letter code** that is either in MaleID or Female ID and a variable called Female that in each row will take the name of the **4 letter code** that is either in MaleID or FemaleID

```{r Female Male ID correction, echo=FALSE}

# Check and remove existing columns
if ("Male" %in% names(Bex)) {
  Bex$Male <- NULL  # Remove the existing Male column
}

if ("Female" %in% names(Bex)) {
  Bex$Female <- NULL  # Remove the existing Female column
}

# Create Male and Female variables
Bex <- Bex %>%
  mutate(
    Male = ifelse(nchar(MaleID) == 3, as.character(MaleID), ifelse(nchar(FemaleID) == 3, FemaleID, NA)),
    Female = ifelse(nchar(FemaleID) == 4, FemaleID, ifelse(nchar(MaleID) == 4, MaleID, NA))
  )

# Create Dyad variable
Bex <- Bex %>%
  mutate(Dyad = paste(Male, Female, sep = " "))


# Check and summarize unique Female and Male IDs after the transformation
unique_female <- unique(Bex$Female)
unique_male <- unique(Bex$Male)
unique_dyad <- unique(Bex$Dyad)

cat("\nUnique Female:", unique_female, "\n")
cat("Unique Male:", unique_male, "\n")
cat("Unique Dyad", unique_dyad, "\n")

kable(table(Bex$Dyad))


```
  
  # Correct from here, mistake were inserted in dyad by changin wrong lines 




  2. Create the variable called **Dyad** created by combining the name of FemaleID and MaleID into one name with a space between the two codes. For information the 3 letter code is the name of the female     while the 4 letter code is the name of the male like displayed here;

    Var1	Freq
Buk Ginq	6
Buk Ndaw	257
Kom Oort	366
Nge Oerw	181
Pom Guat	5
Pom Xian	257
Sey Sirk	584
Sho Ginq	273
Xia Piep	606
Xin Oort	4
Xin Ouli	185


  * They are a few **wrong dyads** that I will have to identify in the dataset and manuallly correct, those wrong dyads to change and identify are:
    -Buk Ginq - 6 occurences
    -Xin Oort - 4 occurences
  
```{r Identify Wrong Dyads, echo=FALSE}

# Part 1: Identify rows with wrong dyads
wrong_dyads <- c("Buk Ginq", "Xin Oort")

# Identify the rows with wrong dyads
wrong_rows <- which(Bex$Dyad %in% wrong_dyads)

# Part 3: Print wron rows and dyads
print(wrong_rows)
print(wrong_dyads)



```
* 

  * I will change the occurences of **Buk Ginq** to **Sho Ginq** for **row 605 to 609** and **row 921**. I know these triasl are with SHo Ginq because the comments metionned Sho in them while Male(ID) gave Buk
  * For the **rows from 2692 to 2695** since, Ouli is in the audience it is unlikely that we had trials with the dyad **Xin Ouli**. Also I think they are little chances that the names of both individuals     were entered wrong. I will replace these occurences where we had **Xin Oort** by **Kom Oort**
  
  * I thus want **Buk** to be replaced in male ID in rows 605 to 609 and row 921 with **Sho** and, **Xin** to be replaced by **Kom** in rows 2692 to 2695 in Male ID before updating Dyad
  
  
```{r Correct Wrong Dyads, echo=FALSE}

# Check if corrections have already been made for "Sho"
if (!all(Bex$MaleID[605:609] == "Sho")) {
  # Correct "Buk" with "Sho" in row 921
  Bex$MaleID[605:609] <- "Sho"
}

# Check if corrections have already been made for "Sho"
if (!all(Bex$MaleID[921] == "Sho")) {
  # Correct "Buk" with "Sho" in row 921
  Bex$MaleID[921] <- "Sho"
}



# Check if corrections have already been made for "Kom"
if (!all(Bex$MaleID[2692:2695] == "Kom")) {
  # Correct "Xin" with "Kom" in rows 2536 to 2539
  Bex$MaleID[2692:2695] <- "Kom"
}


# Delete duplicate rows if any
Bex <- Bex[!duplicated(Bex), ]

# Update Dyad based on the corrected MaleID
Bex <- Bex %>%
  mutate(
    Dyad = paste(
      ifelse(nchar(MaleID) == 3, MaleID, ifelse(nchar(FemaleID) == 3, FemaleID, NA)),
      " ",
      ifelse(nchar(FemaleID) == 4, FemaleID, ifelse(nchar(MaleID) == 4, MaleID, NA))
    )
  )

# Check and summarize unique MaleIDs and Dyads after correction
unique_male <- unique(Bex$MaleID)
cat("Unique Male after correction", unique_male, "\n")

unique_dyad <- unique(Bex$Dyad)
cat("Unique Dyad after correction", unique_dyad, "\n")

kable(table(Bex$MaleID))
kable(table(Bex$Dyad))




```

  

  3. Create the variable called **Trial** where the data will be **sorted by date and dyad** in order to see how many trials have been done with each individual: **One row (per dyad) = one trial** and the    variable called **Day** where the data will be **sorted by date and dyad and day** in order to see how many sessions have been done with each individual: **One day (per dyad) = one session**
  Now, let's proceed with creating the Dyad variable, Trial, and Day:
  
  

```{r Dyad and Day, include=FALSE}
# Create Trial variable
Bex <- Bex %>%
  arrange(Date, Dyad) %>%
  group_by(Dyad) %>%
  mutate(Trial = row_number())

# Create Day variable  # (Changed 'Session' to 'Day' for better clarity)
Bex <- Bex %>%
  arrange(Dyad, Date) %>%
  group_by(Dyad, Date) %>%
  mutate(Day = cur_group_id())

```
4. Make a summary of trial and session so I can see see how many trials and sessions have been done with the individuals
```{r Dyad and Day Summary, echo=FALSE}
# Summary of Trial and Day
summary_trial <- Bex %>%
  group_by(Dyad) %>%
  summarise(Num_Trials = max(Trial))

summary_Day <- Bex %>%
  group_by(Dyad) %>%
  summarise(Num_y = max(Day))

cat("Trial Summary:\n")
print(summary_trial)

cat("\nDay Summary:\n")
print(summary_Day)

kable(table(Bex$Dyad))

```


5. After relfection I decided to **remove every column** that is with PomGuat since they are not enough trials for this Dyad and since we then changed PomGuat for PomXian. I have 5 occurnces to change. For easier manipulation I will remove every row where there is **Guat**

```{r Remove PomGuat, echo=FALSE}

# Count the rows before modifications
before_rows <- nrow(Bex)

# Remove rows where "Guat" is present in FemaleID
Bex <- Bex %>% filter(!grepl("Guat", FemaleID, ignore.case = TRUE))

# Count the rows after modifications
after_rows <- nrow(Bex)

# Display the change in rows
cat("Change in Rows: ", after_rows - before_rows, "\n")

```

  

#### Female Corn and Male Corn 

* The idea is that for each Dyad, we gave an amount of corn to attract the monkey of a dyad to the right distance of his partner for a trial by putting corn in experiment box that he could get by approaching. We repeated this step as much as needed to have our Dyad at the desired distance to continue the trials from the previous day of experimentation. This means I will only Keep the last number per dyad and day for each day. 
* I decided to create **two variables**, that are called **PlacementMale** and **PlacementFemale** that will only keep the final amount of corn given to each individual within a day of experiment

```{r FemaleMale Corn, echo=FALSE}



Bex <- Bex %>%
  arrange(Dyad, Date) %>%
  group_by(Dyad, Day) %>%
  mutate(
    PlacementMale = last(MaleCorn),
    PlacementFemale = last(FemaleCorn)
  )

```

#### DyadDistance - Creation of proximity
* I would like to create a variable called proximity to have another measure of the proximity of the individuals. 
* First lets look at the maximum and minimum distance found in Dyad Distance
```{r DyadDistance Max & Min, echo=FALSE}
# Find maximum distance
max_distance <- max(Bex$DyadDistance, na.rm = TRUE)

# Find minimum distance
min_distance <- min(Bex$DyadDistance, na.rm = TRUE)

# Print the results
cat("Maximum Distance:", max_distance, "\n")
cat("Minimum Distance:", min_distance, "\n")

```
* The **minumum Distance** is **0m** while the **maximum Distance** is **10m**
* Now lets create a new variable called **Proximity** using the distances found in **DyadDistance** on the following model:
  a. 0 = Contact
  b. 1 - 2 = Very close
  c. 2 - 3 = Close
  d. 4 - 5 = Distant
  e. 5 - 6 = Far
  d. 7 - 8 = Very Far
  f. 9 - 10 = Maximum Distance
  
```{r Proximity, echo=FALSE}
  # Assuming 'DyadDistance' is the name of your distance variable
Bex <- Bex %>%
  mutate(
    Proximity = case_when(
      DyadDistance == 0 ~ "Contact",
      between(DyadDistance, 1, 2) ~ "Very Close",
      between(DyadDistance, 2, 3) ~ "Close",
      between(DyadDistance, 4, 5) ~ "Distant",
      between(DyadDistance, 5, 6) ~ "Far",
      between(DyadDistance, 7, 8) ~ "Very Far",
      between(DyadDistance, 9, 10) ~ "Maximum Distance",
      TRUE ~ NA_character_
    )
  )

```

* The idea is that for each Dyad, we gave an amoun of corn to attract the monkey of a dyad to the right distance of his partner for a trial by putting corn in experiment box that he could get by approaching. We repeated this step as much as needed to have our Dyad at the desired distance to continue the trials from the previous day of experimentation. This means I will only Keep the last number per dyad and day for each day

* DyadDistance - Creation of proximity
* Dyad Response - Detailed cleaning

* Reminder: The different behaviors that are coded in **DyadResponse** are: **Distracted**, **Female aggress male**, **Male aggress female**, **Intrusion**, **Loosing interest**, **Not approaching**, **Tolerance** and **Other**
    * I will change the columns associated to each behavior (i.e. Response) of  **DyadResponse**    into dichotomic variables in order to see the frequency of each behaviour
    * This will allow me to see which behavior occurred more than others, and what differences are between dyads 
    * As multiple response could occur within the same trial, multiple behaviors can be found in a single cell. I will create a  hierarchy to reduce the amount of behaviors assigned to each trial (if  there     is more than one). This will also be complemented with the information found in the column comments
      1. correct any mistakes (ex. if tolerance and aggression are together aggression>tolerance)
      2. assign as few labels per trial 
      3. get a better view and understanding of the data and the most common behaviours produced by each dyad
      4. create variables that can complement the behaviour found (ex. not approaching + looks at partner would be looks at partner + a new variable called hesistant to see when the did not come but look at         the other individual / )
      

      - Create a table with each combination existing
      
      - Decide what is more important
* **Dyad Response Hierarchy** Projection of the hierarchy (changes will be made)
      - Aggression > Tolerance
      - Tolerance > Not approaching -> Create a variable called hesistant in         addtion to the tolerance count to see frequency of tolerance                 behaviour that happened after > 1min
      - Tolerance > Loosing interest
      - Tolerance > Intrusion      
      - Not approaching = looking box but not coming while Loosing interest           = not paying attention to the box
       - Intrusion > Loosing interest
      - Intrusion > Not approaching
      - Not approaching > Looks at partner
      - We can code every look at partner as no approaching and keep the             count of looks at partner as additional information       
      - Not approaching >?> Loosing interest ? !!
       - Define distracted
      - Not approaching > Distracted
      - Aggression > Not approaching
      - Other > Look case by case and categorize depending of behavior     
      - Remarks may be used for the same reason
        

  * First I want to see how many rows in DyadResponse have more than one entry per cell
  
```{r DyadResponse MultipleResponse, echo=FALSE}
#Rows with more than1 character
rows_with_multiple_entries <- which(sapply(Bex$DyadResponse, function(x) length(unlist(strsplit(as.character(x), ";"))) > 1))

# Display the rows with multiple entries in DyadResponse
View(Bex[rows_with_multiple_entries, ])

# Print the amount of cells with multiple entries and the total number of rows
cat("Number of rows with multiple entries in DyadResponse: ", length(rows_with_multiple_entries), "\n")

```


* Now that I know that they are 230 rows with multiple entries I will print each combinations to see which one I have to print and also display the combinations once the data is split. 
* I will make an intermediary summary to see that state of DyadResponse at the moment

* A. Summary od DyadResponse

* B.Idnetify Rows with more than 1 entry

*  Step 1: Identify Rows with More than 1 Entry
rows_with_multiple_entries_1 <- which(sapply(Bex$DyadResponse, function(x) length(unlist(strsplit(as.character(x), ";"))) > 1))

Display the rows with more than 1 entry in DyadResponse
knitr::kable(Bex[rows_with_multiple_entries_1, ])

* Print the amount of cells with more than 1 entry and the total number of rows
cat("Number of rows with more than 1 entry in DyadResponse: ", length(rows_with_multiple_entries_1), "\n")

* C. Identify Rows with more than 2 entry
```{r DyadResponse > 2 entry, echo=FALSE}
# Step 1: Identify Rows with More than 1 Entry
rows_with_multiple_entries_1 <- which(sapply(Bex$DyadResponse, function(x) length(unlist(strsplit(as.character(x), ";"))) > 1))

# Print the amount of cells with more than 1 entry and the total number of rows
cat("Number of rows with more than 1 entry in DyadResponse: ", length(rows_with_multiple_entries_1), "\n")

```
* D. 
```{r ,echo=FALSE}
# Step 3: Extract Unique Combinations for More than 1 Entry
all_combinations_1 <- unlist(lapply(rows_with_multiple_entries_1, function(row) {
  unique_chars <- unlist(strsplit(as.character(Bex$DyadResponse[row]), ";"))
  combn(unique_chars, 2, FUN = function(x) paste(x, collapse = " & "))
}))

# Step 4: Count Occurrences of Unique Combinations for More than 1 Entry
combination_counts_1 <- table(all_combinations_1)

# Display Unique Combinations and Counts for More than 1 Entry
cat("Unique Combinations and Counts for More than 1 Entry:\n")
for (entry in names(combination_counts_1)) {
  cat(sprintf("%-25s %d\n", entry, combination_counts_1[[entry]]))
  
after_summary4 <- nrow(Bex)}

# Display the change in occurrences
cat("Change in Occurrences for the Chunk (Female aggress male > Not approaching): ", after_summary4 - before_summary, "\n")
```


 6. Male agress female > Not approaching : Remove Not approaching if there is Male aggress female (2x)
```{r Male agress female > Intrusion, echo=FALSE}
# Count occurrences before modifications
before_summary <- nrow(Bex)
# 6. Remove rows with 'Not approaching' if 'Male aggress female' is present
Bex <- Bex[!(grepl("Not approaching", Bex$DyadResponse) & grepl("Male aggress female", Bex$DyadResponse)), ]

# Count occurrences after modification
after_summary6 <- nrow(Bex)

# Display the change in occurrences
cat("Change in Occurrences for the Chunk (Male aggress female > Not approaching): ", after_summary6 - before_summary, "\n")
```

 7. Tolerance > Distracted: Remove Distracted if there is tolerance (3x)

```{r Tolerance > Distracted, echo=FALSE}

# Count occurrences before modifications
before_summary <- nrow(Bex)

# Tolerance & Distracted: 7.Remove Distracted if there is tolerance
Bex <- Bex[!(grepl("Tolerance", Bex$DyadResponse) & grepl("Distracted", Bex$DyadResponse)), ]

# Count occurrences after modification
after_summary7 <- nrow(Bex)

# Display the change in occurrences
cat("Change in Occurrences for the Chunk Tolerance > Distracted: ", after_summary7 - before_summary, "\n")

```

8.Female agress male > Tolerance: Remove Tolerance if there is Female agress male (23x)
 
```{r Female agress male > Tolerance, echo=FALSE}
# Count occurrences before modifications
before_summary <- nrow(Bex)

# 8. Remove rows with 'Tolerance' if 'Female aggress male' is present
Bex <- Bex[!(grepl("Tolerance", Bex$DyadResponse) & grepl("Female aggress male", Bex$DyadResponse)), ]

# Count occurrences after modification
after_summary8 <- nrow(Bex)

# Display the change in occurrences
cat("Change in Occurrences for the Chunk (Tolerance & Female aggress male): ", after_summary8 - before_summary, "\n")

```



 9.Tolerance > Loosing interest: Remove Losing interest if there is Tolerance (13x)
```{r Tolerance > Loosing interest, echo=FALSE}
# Count occurrences before modifications
before_summary <- nrow(Bex)

# Count occurrences after modification
after_summary9 <- nrow(Bex)

# Display the change in occurrences
cat("Change in Occurrences for the Chunk (Tolerance & Losing interest): ", after_summary9 - before_summary, "\n")


```
 10.Male agress female > Tolerance : Remove Tolerance if there is Male agress male (31)
```{r Male agress female > Tolerance, echo=FALSE}
 # Count occurrences before modifications
before_summary <- nrow(Bex)

# 10. Remove rows with 'Tolerance' if 'Male aggress female' is present
Bex <- Bex[!(grepl("Tolerance", Bex$DyadResponse) & grepl("Male aggress female", Bex$DyadResponse)), ]

# Count occurrences after modification
after_summary10 <- nrow(Bex)

# Display the change in occurrences
cat("Change in Occurrences for the Chunk (Tolerance & Male aggress female): ", after_summary10 - before_summary, "\n")

```
 11.Tolerance > Not approaching: Remove Not approaching if there is tolerance (6x)
```{r Tolerance > Not approaching, echo=FALSE}
# Count occurrences before modifications
before_summary <- nrow(Bex)

# 11. Remove rows with 'Not approaching' if 'Tolerance' is present
Bex <- Bex[!(grepl("Not approaching", Bex$DyadResponse) & grepl("Tolerance", Bex$DyadResponse)), ]


# Count occurrences after modification
after_summary11 <- nrow(Bex)

# Display the change in occurrences
cat("Change in Occurrences for teh Chunk (Tolerance & Not approaching): ", after_summary11 - before_summary, "\n")
```

* Looks at partner &  Other 1                  - Display line for detailed check (1x)
 * Not approaching &  Losing interest 46        - Keep both, I will consider doing a detailled check
 * Not approaching &  Distracted 7              - Display line for detailed check
 * Not approaching &  Other  1                  - Display line for detailed check
 * Tolerance &  Other        8                  - Display line for detailed check



* Code to display rows numbers and the response in DyadResponse that have mroe than one entry



* Other Reponse - DEtailed cleaning to delete the column
* Audience - Creation of Amount Audience and Density
* ID Individua1 - Not sure yet
* Intruder ID 
* Remarks - Detailed Cleaning
* Intrusion
* Not Approaching
* Lossing Interest
* Distracted
* MultipleResponse
* Amount Audience
* DyadDistance
* Distance
* No trial


#### Code to keep and place again
# Code to settle 

I also chose to directly create new dichotomic variables for "Not approaching", "Intrusion", "Losing interest", "Distracted", for this I would like the function to
  1.Check if there is a **value different than "No individual"**
  2.**If the value ≠"No individual"** then I want it to **take the response found in "DyadResposne"** 

```{r Create dichotomous variables, echo=FALSE}
# Check if the "MultipleResponses" column already exists
if (!"MultipleResponses" %in% names(Bex)) {
  # Replace NA in IDindividual1 by "No individual"
  Bex$IDIndividual1[is.na(Bex$IDIndividual1)] <- "No individual"

  # Check for multiple responses
  Bex$MultipleResponses <- ifelse(
  Bex$IDIndividual1 != "No individual" & grepl("[;,] ?", Bex$DyadResponse),
  ">1 Response",
  "Single Response"
)

  
  View(Bex)
} else {
  cat("The 'MultipleResponses' column already exists. No changes made.\n")
}
```

```{Check Responses in DyadResponse for Id1, echo=FALSE}
# Count occurrences of each behavior in DyadResponse
count_NotApproaching <- sum(grepl("Not approaching", Bex$DyadResponse))
count_Intrusion <- sum(grepl("Intrusion", Bex$DyadResponse))
count_LosingInterest <- sum(grepl("Losing interest", Bex$DyadResponse))
count_Distracted <- sum(grepl("Distracted", Bex$DyadResponse))

cat("Occurrences of 'Not approaching' in DyadResponse:", count_NotApproaching, "\n")
cat("Occurrences of 'Intrusion' in DyadResponse:", count_Intrusion, "\n")
cat("Occurrences of 'Losing interest' in DyadResponse:", count_LosingInterest, "\n")
cat("Occurrences of 'Distracted' in DyadResponse:", count_Distracted, "\n")


# Count the number of '1's in the new variables
count_NotApproaching_1 <- sum(Bex$NotApproaching == 1)
count_Intrusion_1 <- sum(Bex$Intrusion == 1)
count_LosingInterest_1 <- sum(Bex$LosingInterest == 1)
count_Distracted_1 <- sum(Bex$Distracted == 1)

cat("Occurrences of '1' in 'NotApproaching':", count_NotApproaching_1, "\n")
cat("Occurrences of '1' in 'Intrusion':", count_Intrusion_1, "\n")
cat("Occurrences of '1' in 'LosingInterest':", count_LosingInterest_1, "\n")
cat("Occurrences of '1' in 'Distracted':", count_Distracted_1, "\n")

```


{r Check changes of dichotomic variables}

### Exploratory Graph (To organise)

####Dyad, Distance & Date

* Trials of grpahs, I will have to check all of them

* My goal here is too see if each dyad have an general evolution of their dyad distance trough time and how many varaition do they have

```{r Dyad Distance & Date, echo=FALSE}
# Load required libraries
library(ggplot2)
library(dplyr)
library(lubridate)

# Check if the DyadDistance column exists
if("DyadDistance" %in% colnames(Bex)) {
    # Convert Date column to Date format if it's not already
    Bex$Date <- as.Date(Bex$Date)

    # Plot using Date
    plot <- ggplot(data = Bex, aes(x = Date, y = DyadDistance, group = Dyad, color = Dyad)) +
      geom_smooth(se = FALSE, method = "loess") +
      theme_minimal() +
      labs(x = "Date", y = "Dyad Distance", title = "Dyad Distance Over Time", color = "Dyad")

    # Print the plot
    print(plot)
} else {
    print("DyadDistance column not found in Bex dataframe")
}


```


```{r Other graphs}


# Load required libraries
library(ggplot2)
library(dplyr)

# Ensure Date is in the correct format
Bex$Date <- as.Date(Bex$Date)

# Plot with smoothed lines and confidence intervals with improved readability
daily_plot <- ggplot(data = Bex, aes(x = Date, y = DyadDistance, group = Dyad, color = Dyad)) +
  geom_smooth(method = "loess", se = TRUE, alpha = 0.2, size = 1) + # Adjusted alpha and line size
  theme_minimal() +
  theme(legend.position = "right") + # Adjust legend position
  labs(x = "Date", y = "Dyad Distance", title = "Dyad Distance Over Time with Confidence Interval", color = "Dyad") +
  expand_limits(y = c(0, NA)) # Expand y-axis limits if needed

# Print the daily plot
print(daily_plot)

                    
```

```{r daily graph, echo=FALSE}
library(ggplot2)
library(dplyr)
library(lubridate)

# Ensure Date is in the correct format
Bex$Date <- as.Date(Bex$Date)

# Aggregate data by month and calculate mean and SD
monthly_stats <- Bex %>%
  mutate(Month = floor_date(Date, "month")) %>%
  group_by(Dyad, Month) %>%
  summarise(
    Mean_DyadDistance = mean(DyadDistance, na.rm = TRUE),
    SD_DyadDistance = sd(DyadDistance, na.rm = TRUE)
  )

# Faceted plot with Mean Points and Error Bars for each month
faceted_monthly_plot <- ggplot(data = monthly_stats, aes(x = Month, y = Mean_DyadDistance, color = Dyad)) +
  geom_point(size = 2) +
  geom_errorbar(aes(y))
```

```{r Monthly graph, echo=FALSE}
# Load required libraries
library(ggplot2)
library(dplyr)
library(lubridate)

# Ensure Date is in the correct format
Bex$Date <- as.Date(Bex$Date)

# Aggregate data by month and calculate mean and SD
monthly_stats <- Bex %>%
  mutate(Month = floor_date(Date, "month")) %>%
  group_by(Dyad, Month) %>%
  summarise(
    Mean_DyadDistance = mean(DyadDistance, na.rm = TRUE),
    SD_DyadDistance = sd(DyadDistance, na.rm = TRUE),
    .groups = 'drop' # This will remove the grouping after summarisation
  )

# Faceted plot with Mean Points and Error Bars for each month
faceted_monthly_plot <- ggplot(data = monthly_stats, aes(x = Month, y = Mean_DyadDistance, color = Dyad)) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = Mean_DyadDistance - SD_DyadDistance, ymax = Mean_DyadDistance + SD_DyadDistance), width = 0.2) +
  facet_wrap(~ Dyad, scales = 'free_y') + # Faceting by Dyad, with free y scales for each facet
  theme_minimal() +
  labs(x = "Month", y = "Mean Dyad Distance", title = "Monthly Mean Dyad Distance with SD by Dyad", color = "Dyad")

# Print the faceted monthly plot
print(faceted_monthly_plot)
```

```{r last test before sleep, echo=FALSE}

library(ggplot2)
library(dplyr)
library(lubridate)

# Ensure Date is in the correct format
Bex$Date <- as.Date(Bex$Date)

# Aggregate data by month and calculate mean and SD
monthly_stats <- Bex %>%
  mutate(Month = floor_date(Date, "month")) %>%
  group_by(Dyad, Month) %>%
  summarise(
    Mean_DyadDistance = mean(DyadDistance, na.rm = TRUE),
    SD_DyadDistance = sd(DyadDistance, na.rm = TRUE),
    .groups = 'drop'
  )

# Calculate the grand mean DyadDistance for each Dyad
grand_means <- monthly_stats %>%
  group_by(Dyad) %>%
  summarise(Grand_Mean_DyadDistance = mean(Mean_DyadDistance, na.rm = TRUE))

# Faceted plot with Mean Points, Error Bars, Lines for each month, and Grand Mean Line
faceted_monthly_plot_with_lines <- ggplot(data = monthly_stats, aes(x = Month, y = Mean_DyadDistance, color = Dyad, group = Dyad)) +
  geom_line() +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = Mean_DyadDistance - SD_DyadDistance, ymax = Mean_DyadDistance + SD_DyadDistance), width = 0.2) +
  geom_hline(data = grand_means, aes(yintercept = Grand_Mean_DyadDistance, color = Dyad), linetype = "dashed") +
  facet_wrap(~ Dyad) + # Removed scales = 'free_y' for a uniform scale
  theme_minimal() +
  labs(x = "Month", y = "Mean Dyad Distance", title = "Monthly Mean Dyad Distance with SD by Dyad", color = "Dyad")

# Print the faceted monthly plot with lines and grand mean
print(faceted_monthly_plot_with_lines)

```

```{r Still not asleep?, echo=FALSE}
```{r daily graph2, echo=FALSE}
library(ggplot2)
library(dplyr)
library(lubridate)

# Ensure Date is in the correct format
Bex$Date <- as.Date(Bex$Date)

# Aggregate data by month and calculate mean and SD
monthly_stats <- Bex %>%
  mutate(Month = floor_date(Date, "month")) %>%
  group_by(Dyad, Month) %>%
  summarise(
    Mean_DyadDistance = mean(DyadDistance, na.rm = TRUE),
    SD_DyadDistance = sd(DyadDistance, na.rm = TRUE),
    .groups = 'drop' # Avoid regrouping after summarise
  )

# Calculate overall mean and standard deviation for reference
overall_mean <- mean(Bex$DyadDistance, na.rm = TRUE)
overall_sd <- sd(Bex$DyadDistance, na.rm = TRUE)

# Faceted plot with Mean Points and Error Bars for each month
faceted_monthly_plot <- ggplot(data = monthly_stats, aes(x = Month, y = Mean_DyadDistance, color = Dyad)) +
  geom_point(size = 3) + # Slightly larger points for visibility
  geom_errorbar(aes(ymin = Mean_DyadDistance - SD_DyadDistance, ymax = Mean_DyadDistance + SD_DyadDistance), width = 0.2) +
  geom_hline(yintercept = overall_mean, linetype = "dashed", color = "red") + # Line for overall mean
  geom_ribbon(aes(ymin = overall_mean - overall_sd, ymax = overall_mean + overall_sd), fill = "red", alpha = 0.2) + # Shaded area for overall SD
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) + # Rotate x labels for better readability
  labs(x = "Month", y = "Mean Dyad Distance", title = "Monthly Mean Dyad Distance by Dyad", color = "Dyad")

# Print the faceted monthly plot
print(faceted_monthly_plot)

```
  
   * I want to use the date to know **how many sessions** have been done with each dyads in my experiment. 
    * I will create a variable called **Session** where **1 session = 1 day**
    * The data has values from the **14th of September 2022** until the **13th of September 2023**
    * I will also create a variable called **Trial** to know how many trials have been done with each dyad where **1 row = 1 trial** 
    
    * I may consider, in parallel of my hypothesis, to separate the data in *4 seasons* to make a preliminary check of a potential effect of seasonality. Nevertheless the fact that we did not use anywithout      tools to mesure the weather and the idea to make a categorization in 4 seasons without considering the actua quite arbitrary. I may do it but with no intention to include this in my scientific report.
    l temperature, food quantitiy and other elements related to seasonailty make this categorizationn a categorization where 12 months of          data will be separated in 4 categories
   


* But before I may want to make a few changes already by merging **Male corn** and **Male placement corn** into " Male corn" and maybe replacing all of the NA's in "Other response" by response

#Lines to check unique values in MaleFemaleID to see if they are any problems with it
# Unique values in MaleID
unique_male_ids <- unique(Bex$MaleID)

# Unique values in FemaleID
unique_female_ids <- unique(Bex$FemaleID)

# Print the unique values
cat("Unique values in MaleID: ", toString(unique_male_ids), "\n")
cat("Unique values in FemaleID: ", toString(unique_female_ids), "\n")








# Sections below are here for the organization of my paper and will be worked on once the data cleaning and exploration is done

## 3. Describing the data

## 4.Visualizing the data

## 5.Research question & Hypothesis

### Research question

-   What factors influence the rate at which individuals (vervets) learn
    to tolerate each other in a controlled box experiment?

-   Ex: The rate at which individuals (vervets) learn to tolerate each
    other in a box experiment is influenced by social factors (audience,
    social network, behavior of the partner) and idioyncratic factors
    (age, rank)

### Hypothesis

-   1.  Hypothesis about the Presence of High-Ranking Individuals:

The presence of a higher number of high-ranking individuals in the
audience will negatively correlate with the level of tolerance achieved
among vervets in the box experiment. This is expected to result in
higher frequencies of aggressive behaviors, intrusions, and loss of
interest, particularly from lower-ranking individuals.

-   2.  Hypothesis about Partner Agonistic Behaviors:

Vervets tolerance levels in the box experiment will be influenced by
their partner’s display of agonistic behaviors. Specifically, partners
who exhibit more frequent agonistic behaviors towards their partner will
lead to decrease in their motivation to participate in future trials.

-   3.  Hypothesis about the Establishment of an Optimal Distance:

During the box experiment, vervet dyads will establish an “optimal”
distance for interaction, characterized by a higher frequency of
tolerance compared to other distances. This optimal distance is expected
to signify that the individuals tolerate each other more effectively at
this specific proximity .

-   4.  Hypothesis about Age and Rank:

The age and rank of individual vervets within the group will influence
the success of the trials in the box experiment. Specifically, older and
higher-ranking individuals are expected to exhibit lower rates of
success compared to dyads consisting of younger and lower-ranked
individuals. This decrease in success is anticipated to be associated
with a higher frequency of aggressive behaviors displayed by older and
higher-ranking individuals towards their partners. (I’m not sure this
hypothesis makes sens, I have the feeling age and rank must have an
influence but I don’t know how to put it, I will think about it)

-   5.  Hyptohesis about seasonality

Seasonality is expected to impact the motivation of vervet dyads to
participate in the box experiment. We hypothesize that dyads will have
lower motivation, as indicated by a reduced number of trials, during the
summer months compared to the winter months. This difference in
motivation is likely influenced by temperature and food availability. To
test this hypothesis, we will categorize the data into four seasonal
periods, each spanning four months, and analyze whether there is a
significant effect of seasonality on the motivation to engage in the
trials.

## 6.Statistical tests and analisis of the data

### Statistical tests

-   **Hypothesis 1**: Influence of High-Ranking Individuals

Variables Needed:

**DyadResponse** (specifically, “aggression” responses)
**Amountaudience** (to measure the number of individuals in the
audience) **Audience…15** (to identify the names of individuals in the
audience for calculating dominance ranks) **Elo rating** of the
individuals based on the ab libitum data collected in IVP (which I have
to calculate asap)

Statistical Analysis:**Logistic Regression**, as it could analyze the
influence of high-ranking individuals on the occurrence of aggression in
dyad responses. This will help determine whether the presence of
high-ranking individuals affects the likelihood of aggression.

-   **Hypothesis 2**: Impact of Partner’s Agonistic Behaviors

Variables Needed:

-   **DyadResponse** (specifically, “aggression” responses)
-   **MaleagressF** (male’s aggression towards female)
-   **FemaleaggressM** (female’s aggression towards male)

Statistical Analysis: **Logistic Regression** as it could be used to
assess how the occurrence of aggression in dyad responses is influenced
by the partner’s gender-specific agonistic behaviors.

-   **Hypothesis 3**: Identification of an Optimal Interaction Distance

Variables Needed:

-   **DyadDistance** (distance between boxes)
-   **Tolerance** (as a binary outcome)

Statistical Analysis: **generalized Linear Model (GLM)** to investigate
whether there is an optimal distance that leads to a higher likelihood
of tolerance (Tolerance = 1).

-   **Hypothesis 4**: Role of Age and Rank

Variables Needed:

-   **Tolerance** (as a binary outcome)
-   **Male and Female** (to identify individuals’ ages and ranks)
-   **Dyad** (to link individuals to dyads)
-   **Birthdate** to calculate the age of each individual

Statistical Analysis: **Logistic Regression** Logistic regression can be
employed to determine whether the age and rank of individual vervets
within dyads have an impact on the likelihood of tolerance (Tolerance =
1).

-   **Hypothesis 5**: Influence of Seasonality

Variables Needed:

-   **Date** (to categorize data into seasons)
-   **Trial** (to count the number of trials in each season) and the
    data for at least 365 days so i can separate the data in 4 (1 year =
    4 seasons = 12\*4 month) to see if they may be an effect of
    seasonality on the motivation (amount of trials) of the dyads

Statistical Analysis:

ANOVA or Kruskal-Wallis Test: Depending on the distribution of your
trial data, you can use either ANOVA (if the data are normally
distributed) or the Kruskal-Wallis test (for non-normally distributed
data) to assess the impact of seasonality on the number of trials. If
significant differences are found, you can follow up with post-hoc tests
to identify which seasons differ from each other. Please note that the
effectiveness of these analyses may depend on the distribution of your
data and specific research objectives. You may also consider conducting
exploratory data analysis (e.g., visualization) to gain a better
understanding of your dataset before performing these analyses.
Additionally, if you have specific questions about data preprocessing or
variable transformations, feel free to ask for further guidance. –> I
took this from ChatGPT, I have to look more into it

**REMARKS**: So here are a few updates I made in the document. I also
planned to send my cleaned data to Radu (the statistician of UNINE) as
he was keen to help me find the right test. Of course I will also look
again in Bshary’s and Charlotte’s work with the boxes and improve these
suggestions that are quite simple for now

Also I still have to clean the last grpahs about male/female aggression
as I didn’t finish that yet. I juste wanted to share my hypothesis and
ideas for statistics so I can soon go into the “serious” work

Anyway, thank you in advance for your help \<3

Michael

## 7. Plotting the results of the analysis

## 9. Interpretation of the results

## 10. Comeback on the research question and hypothesis

## 11. Bibliography

## 12. Organization for my paper

-   Introduction
    -   Tolerance humans, primates
    -   Apes vs monkeys / Captivity vs Wild
    -   IVP: Wild habituated vervets, experiments possible
    -   Paper Bshary, Canteloup… Prolongation study
    -   Relevance idea/topic research
    -   Research question & hypothesis

But: intro need triangle shape: broad to narrow end wiht research
question> tolerance importance \> animal reign, actual knowledge/
direction knowledge we need \> show how my experiment goes in that way
How to adress the gap, answer with research question

Then explain why choosing vervet monkeys, (IVP in methods), sociality,
experiments made

-   Methods

    -   IVP, research area, (goal, house, type people)

    -   Population: groups, dyads, male/female, ranks..

    -   Box material: boxes, remotes, batteries, camera, tripod, corn
        (no marmelade ;), (water spray, security reason, non agressive
        way to select individuals and not engage with mokeys when
        reachrging boxes with corn), pattern, previous distances,
        tablets, box experiment form

    -   Tablets

    -   (No observers mentionned)

    -   Habituation boxes > individuals trained to recognice boxes, they
        have differernt levels of habituation

    -   Patterns > appendix, mention similar to habituation, use to
        recognize box but efficieny depeds of experience)

    -   Selection dyads > assigment from elo rating (different rank), if
        above average bond no dyad made, if not possible, availibilty of
        monkey also factor !! Non random can be a problem, think about
        why and how you selected data We created variations in dyads
        made by different sex, rank and not above average bonde
        (calculate bondeness)

    -   Amount corn, do you want to mention it> maybe important
        Calculate corn during and placement cf paper on corn /food
        motivation

    -   Corn (daily intake vervet % made from corn, cf site we saw, cf
        screenshot, comapre paper previousely made an all)

    -   1st dyad trial (BD) > appendix

    -   Videos > details appendix

    -   Finding dyads > appendix

    -   Placement to attract them > meniton if statiscial made on
        placement corn

    -   Trials (1 session = max 15 trials/in total) (session could be
        broken in different sub sessions to reach 15 trials max)

    -   If agression > 1m / If 2x tolerance \< 1m , also if not
        approaching > 1m ( if no tolerance increase distance except if
        intrusion) (borgeaud > expectation fo aggression)

    -   Time of the day > appendix

    -   Territory? > appendix

    -   Amount sessions p day/week, how we chose the moment to follow
        them >appendix

    -   Problems/ unplanned events: weather, BGE’s, not finding the
        monkeys (group, dyad or individual), dispersal of males, river
        crossing, inacessibility (experiments or boxes), low vision
        (experiments or monkeys),> appendix

    -   (Where do i mention the confounding variables?) > look in
        litterature, if something that could affect and already reported
        in papers check, oterhwise exclude “normal life” factors for
        both monekys and Experimenter

    -   Types of experimental plan

    -   Statistical tests (for each hypothesis)

-   Analysis

-   Results

-   Interpretation

-   Conclusion


#########

# Glossary
* **Tolerance**: Tolerance: An individual has an encounter with a conspecific and
  can freely leave but remains in the encounter without acting aggressively
  toward the conspecific. (Pisor & Surbeck, 2019)
* **Agression**
* **Session** 
* **Trial**
* **Group**: In the Primate order, groups are individuals “which remain [physically] together in or separate from a larger unit” and interact with each other more than with other individuals.6 This            definition does not cover all uses of the word “group” in the social sciences (e.g., human identity groups who identify with a common name or symbol may or may not interact with one another more frequently   than with other individuals). Because of this ambiguity, we use the word “community” when referring to humans to better capture the notion of spatial proximity, per Ref. 54. Members of the same group are    referred to as “same-group” and those from another group “extra-group.” (Pisor & Surbeck, 2019)


# Bibliography
 • Pisor, A. C., & Surbeck, M. (2019). The evolution of intergroup tolerance in nonhuman primates and humans. Evolutionary Anthropology: Issues and Reviews. Advance online publication. https://doi.org/10.1002/evan.21793
(Pisor & Surbeck, 2019)


# Annex

#### Annex 1 : View of the dataset when imported - First 6 entries of each variable 
* We can see here the brief view of the **original dataset** names **BoxEx**when i initially imported it as seen in **section 0: Opening data** 



```{r View of the data Boxex, echo=FALSE}

# Display the original dataset that is name Boxex
pander(head(Boxex), style = "rmarkdown", caption = "First Few Entries") 

```
